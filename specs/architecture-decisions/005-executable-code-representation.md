# ADR-005: 実行可能コードのJSON化適用範囲

## Status

**承認済み** (Accepted)

## Context

### Background

Ukiyoue フレームワークは、ADR-001 により「JSON + JSON Schema + JSON-LD」をデータ表現形式として採用している。しかし、すべての成果物をJSON化すべきかという疑問が生じた。

特に **Layer 4: Implementation & Test** には以下の成果物が含まれる：

- **Source Code** (JavaScript/Python/Java/Go など)
- **Test Code** (同上)
- **Physical Data Model** (SQL DDL)
- **Infrastructure as Code** (Terraform/CloudFormation/Ansible など)

これらは**プログラミング言語・形式言語で記述される実行可能コード**であり、以下の特性を持つ：

1. **非曖昧性**: 構文が厳密に定義され、曖昧性がない
2. **実行可能性**: インタープリタ・コンパイラで直接実行可能
3. **ツールチェーン**: IDE・リンター・フォーマッタ・デバッガなどの充実したエコシステム
4. **形式言語**: 既に構造化されたデータ形式として完成している

これらをJSON化すべきか、実装言語のまま扱うべきかの決定が必要である。

### Requirements

この決定は、specs/requirements.md で定義された以下のフレームワーク要件に関連する：

| 要件 ID          | 要件名                 | 関連性                                   |
| ---------------- | ---------------------- | ---------------------------------------- |
| **FR-AUTO-001**  | 構造化された形式の定義 | プログラミング言語は既に構造化されている |
| **FR-AUTO-002**  | 自動バリデーション     | 言語パーサー・リンターで検証可能         |
| **FR-CONV-001**  | セマンティック検索     | コードはConversational要件の対象外か？   |
| **FR-REUSE-001** | コンポーネント化       | 関数・モジュールで既に実現されている     |

### Decision Criteria

| 基準                     | 説明                         | 重要度      |
| ------------------------ | ---------------------------- | ----------- |
| **非曖昧性の維持**       | 実装言語の厳密性を損なわない | 🔴 Critical |
| **実行可能性の保証**     | 実行環境で直接実行できる     | 🔴 Critical |
| **ツールチェーン活用**   | 既存開発ツールを使用可能     | 🔴 Critical |
| **JSON化の必要性**       | JSON化によるメリットがあるか | 🟡 High     |
| **フレームワーク一貫性** | ADR-001との整合性            | 🟡 High     |

## Options

### Option 1: すべてをJSON化する（抽象構文木として）

#### Description

Source Code/Test Code/DB Schema/IaCをすべてJSON形式の抽象構文木（AST）として表現し、JSON Schemaでスキーマ定義する。

#### Pros

- ✅ ADR-001との完全な一貫性
- ✅ 言語非依存の統一的なメタデータ付与
- ✅ JSON-LDによるセマンティック定義が可能

#### Cons

- ❌ AST化が極めて複雑（言語ごとにパーサー実装が必要）
- ❌ 実装者は通常のコードエディタ・IDEを使用できない
- ❌ リンター・フォーマッタ・デバッガなどのツールが使えない
- ❌ 実行前にASTから実装言語へ逆変換が必要
- ❌ コード補完・型チェックなどの開発支援が失われる

#### Evaluation

| 基準                     | 評価 | 説明                                      |
| ------------------------ | ---- | ----------------------------------------- |
| **非曖昧性の維持**       | ⚠️   | ASTは非曖昧だが、実装・保守が現実的でない |
| **実行可能性の保証**     | ❌   | 逆変換プロセスが必要                      |
| **ツールチェーン活用**   | ❌   | 既存ツールが使用不可                      |
| **トレーサビリティ**     | ✅   | JSON-LDで統一的に管理可能                 |
| **保守性**               | ❌   | AST変換ツールの実装・保守が困難           |
| **JSON化の必要性**       | ❌   | 実装言語自体が既に構造化されている        |
| **フレームワーク一貫性** | ✅   | ADR-001と一貫                             |

### Option 2: 実行可能コードは実装言語で直接表現する（JSON化しない）

#### Description

Source Code/Test Code/DB Schema/IaCは、それぞれの実装言語（JavaScript/Python/SQL/HCLなど）で直接表現し、JSON化しない。Ukiyoueフレームワークの適用範囲を「曖昧性を持つ可能性のあるドキュメント」に限定する。

#### Pros

- ✅ 実装者は通常の開発ツール（IDE・リンター・フォーマッタ）を使用可能
- ✅ 実行環境で直接実行可能（変換不要）
- ✅ 言語エコシステムの全機能を活用できる
- ✅ 実装言語自体が既に非曖昧な形式言語である
- ✅ 開発者の学習コストが低い（通常の開発フローと同じ）

#### Cons

- ⚠️ ADR-001の方針からの例外が生じる
- ⚠️ JSON-LDによるセマンティック定義が適用できない
- ⚠️ フレームワーク適用範囲に境界が生まれる

#### Evaluation

| 基準                     | 評価 | 説明                                   |
| ------------------------ | ---- | -------------------------------------- |
| **非曖昧性の維持**       | ✅   | 実装言語自体が非曖昧な形式言語         |
| **実行可能性の保証**     | ✅   | 実行環境で直接実行可能                 |
| **ツールチェーン活用**   | ✅   | 既存ツールをすべて使用可能             |
| **トレーサビリティ**     | ⚠️   | 代替手段が必要（後述）                 |
| **保守性**               | ✅   | 通常の開発フロー（メタデータ同期不要） |
| **JSON化の必要性**       | ✅   | 不要（既に構造化されている）           |
| **フレームワーク一貫性** | ⚠️   | 例外を設けるが、合理的な理由がある     |

### Option 3: メタデータのみJSON、本体は実装言語

#### Description

コード本体は実装言語で記述し、メタデータ（作成者・バージョン・依存関係・**トレーサビリティ情報**など）のみJSON+JSON Schemaで管理する。

例：

```json
{
  "@context": "https://ukiyoue.dev/contexts/source-code.jsonld",
  "file": "src/auth/AuthService.ts",
  "implements": ["API-SPEC-001"],
  "satisfies": ["FR-SEC-003", "NFR-SEC-001"],
  "testedBy": ["TEST-SEC-003"],
  "dependencies": ["src/crypto/HashService.ts"],
  "author": "team-auth",
  "version": "1.2.0"
}
```

#### Pros

- ✅ 実装言語のツールチェーンを活用可能
- ✅ メタデータはJSON-LDで意味定義できる
- ✅ ADR-001との部分的な一貫性
- ✅ **トレーサビリティ情報を統一形式で管理可能**
- ✅ **成果物間の依存関係を明示的に追跡可能**
- ✅ **変更影響分析・カバレッジ分析が容易**

#### Cons

- ❌ **メタデータとコード本体が分離される（同期が困難）**
  - コード変更時にメタデータ更新を忘れるリスク
  - メタデータ更新漏れの検出が困難
  - 2つのファイルを同時に更新する必要がある
- ❌ **メタデータスキーマの設計が複雑化**
  - 言語ごとに異なるメタデータ項目が必要
  - ファイル単位・クラス単位・関数単位のどれで管理するか
- ❌ **メタデータファイルの管理コスト**
  - コードファイル数に比例してメタデータファイルが増加
  - ディレクトリ構造の複雑化
- ⚠️ **既存の言語標準メタデータ（package.json等）との重複**
  - 依存関係・バージョン情報は既存形式と重複する可能性

#### Evaluation

| 基準                     | 評価 | 説明                                         |
| ------------------------ | ---- | -------------------------------------------- |
| **非曖昧性の維持**       | ✅   | 実装言語の非曖昧性を保持                     |
| **実行可能性の保証**     | ✅   | 実行環境で直接実行可能                       |
| **ツールチェーン活用**   | ✅   | 既存ツールを使用可能                         |
| **トレーサビリティ**     | ✅   | JSON-LDで統一的に管理可能                    |
| **保守性**               | ⚠️   | メタデータ同期が課題（ツールで自動化が必要） |
| **JSON化の必要性**       | ⚠️   | メタデータのみ（過剰設計の可能性）           |
| **フレームワーク一貫性** | ⚠️   | 部分的な一貫性                               |

## Options Comparison

### 総合比較表

| 評価軸                   | Option 1: 全JSON化（AST） | Option 2: 実装言語のみ | Option 3: メタデータJSON |
| ------------------------ | ------------------------- | ---------------------- | ------------------------ |
| **非曖昧性の維持**       | ⚠️ AST変換の複雑性        | ✅ 言語仕様で保証      | ✅ 言語仕様で保証        |
| **実行可能性の保証**     | ❌ 逆変換が必要           | ✅ 直接実行可能        | ✅ 直接実行可能          |
| **ツールチェーン活用**   | ❌ 使用不可               | ✅ 全機能利用可能      | ✅ 全機能利用可能        |
| **トレーサビリティ**     | ✅ JSON-LDで統一          | ⚠️ 代替手段が必要      | ✅ JSON-LDで統一         |
| **保守性**               | ❌ AST変換保守が困難      | ✅ 同期不要            | ⚠️ メタデータ同期が課題  |
| **開発者体験**           | ❌ 学習コスト大           | ✅ 通常のフロー        | ⚠️ 2ファイル管理が必要   |
| **フレームワーク一貫性** | ✅ 完全一貫               | ⚠️ 例外あり            | ⚠️ 部分的一貫            |
| **実装の現実性**         | ❌ 極めて困難             | ✅ 追加実装不要        | ⚠️ 同期ツールが必要      |

### トレーサビリティの詳細比較

| 方式                     | 情報の配置       | 同期の必要性 | 検索性  | 保守性           | ツール依存 |
| ------------------------ | ---------------- | ------------ | ------- | ---------------- | ---------- |
| **Option 1: AST**        | JSON内           | 不要         | ✅ 容易 | ❌ AST変換が困難 | 🔴 高      |
| **Option 2: 代替手段**   | 複数箇所（後述） | 方式により   | ⚠️ 分散 | 方式により       | 方式により |
| **Option 3: メタデータ** | 別JSONファイル   | 必要         | ✅ 容易 | ⚠️ 同期が課題    | 🟡 中      |

## Decision

**Option 2: 実行可能コードは実装言語で直接表現する（JSON化しない）**を採用する。

ただし、トレーサビリティについては**代替手段を併用**する。

### Rationale

#### 主要な決定理由

1. **実装言語は既に非曖昧な形式言語である**
   - プログラミング言語・SQL・HCL（Terraformなど）は、厳密に定義された構文を持つ
   - JSON化しても非曖昧性は向上しない（むしろ複雑化する）

2. **実行可能性が最優先**
   - コードは実行されて初めて価値を持つ
   - 実行環境で直接実行できることが必須

3. **開発ツールチェーンの重要性**
   - IDE・リンター・フォーマッタ・デバッガ・型チェッカーなどは開発生産性に不可欠
   - これらを失うコストは、JSON化のメリットを大きく上回る

4. **Conversational要件の対象外**
   - コードは「実行されるもの」であり、「会話的に読まれるもの」ではない
   - FR-CONV-001（セマンティック検索）の優先度は低い

5. **フレームワークの適用範囲を明確化**
   - Ukiyoueは「曖昧性を排除したいドキュメント」に価値を提供する
   - 既に非曖昧な成果物には適用不要

#### Option 3（メタデータJSON）を採用しなかった理由

Option 3はトレーサビリティ管理において優れているが、以下の理由で採用を見送った：

1. **メタデータ同期の困難性**
   - コード変更のたびにメタデータファイルの更新が必要
   - 同期漏れの検出が困難（静的解析ツールの開発が必要）
   - リファクタリング時の保守負担が大きい

2. **ファイル管理の複雑化**
   - コードファイル数に比例してメタデータファイルが増加
   - ディレクトリ構造が複雑化（例: `src/auth/AuthService.ts` + `src/auth/AuthService.meta.json`）

3. **既存エコシステムとの重複**
   - 依存関係は `package.json`/`pyproject.toml` 等で既に管理されている
   - バージョン情報も同様
   - トレーサビリティ情報のためだけに新規ファイル形式を導入するのは過剰

4. **代替手段の存在**
   - トレーサビリティは後述の代替手段で実現可能
   - 代替手段の組み合わせで、同期問題を回避できる

#### トレーサビリティの代替手段

Option 2でトレーサビリティを実現するため、以下の3つの代替手段を組み合わせる：

##### 代替手段A: 言語標準のメタデータ形式

既存の言語標準メタデータファイルを活用：

- **Node.js/Bun**: `package.json`
- **Python**: `pyproject.toml`
- **Rust**: `Cargo.toml`
- **Go**: `go.mod`
- **Java**: `pom.xml` / `build.gradle`

**メリット**:

- ✅ 既存エコシステムとの統合
- ✅ ツールサポートが充実
- ✅ 開発者にとって標準的

**デメリット**:

- ⚠️ プロジェクト単位の情報のみ（ファイル・クラス単位の詳細なトレーサビリティは不可）
- ⚠️ 言語固有（統一的なJSON-LD化が困難）

**適用範囲**: プロジェクト間依存関係、バージョン管理

##### 代替手段B: ソースコード内アノテーション

コードに直接トレーサビリティ情報を埋め込む：

```typescript
/**
 * @implements {API-SPEC-001} User Authentication API
 * @satisfies {FR-SEC-003} Multi-factor authentication
 * @tested-by {TEST-SEC-003} MFA test cases
 */
export class AuthService {
  // ...
}
```

**メリット**:

- ✅ コードと情報が同一ファイル内（同期問題なし）
- ✅ コードレビュー時に可視化される
- ✅ ツールで抽出可能（JSDoc/Sphinx等）

**デメリット**:

- ❌ **トレーサビリティ情報の変更がコード変更として扱われる**
  - 要件番号の変更だけでソースコードのコミット・再ビルド・再デプロイが発生
  - コード変更履歴がトレーサビリティ変更で汚染される
  - CI/CDパイプラインが不必要にトリガーされる
- ❌ 統一的な検索・集計が困難（言語ごとにパーサーが必要）
- ❌ アノテーションの標準化が必要

**適用範囲**: 限定的に使用（クラス・関数の主要な対応関係のみ）

**推奨方針**: トレーサビリティ情報の頻繁な変更が予想される場合は使用しない

##### 代替手段C: 外部トレーサビリティマトリクス（JSON-LD）

別ファイルでトレーサビリティ情報を一元管理：

```json
{
  "@context": "https://ukiyoue.dev/contexts/traceability.jsonld",
  "@type": "TraceabilityMatrix",
  "project": "auth-service",
  "traces": [
    {
      "source": "src/auth/AuthService.ts",
      "implements": ["API-SPEC-001", "API-SPEC-002"],
      "satisfies": ["FR-SEC-003", "NFR-PERF-001"],
      "testedBy": ["TEST-SEC-003", "TEST-PERF-001"],
      "dependencies": ["src/crypto/HashService.ts"]
    },
    {
      "source": "src/crypto/HashService.ts",
      "satisfies": ["NFR-SEC-002"],
      "testedBy": ["TEST-SEC-005"]
    }
  ]
}
```

**メリット**:

- ✅ トレーサビリティ情報の変更がコード変更を引き起こさない
- ✅ JSON-LDで統一的に管理可能
- ✅ セマンティック検索・変更影響分析が容易
- ✅ 複数ファイルの関係性を一覧できる

**デメリット**:

- ⚠️ コードファイルパスの変更時に同期が必要（ただし自動化可能）
- ⚠️ トレーサビリティファイルの保守が必要

**適用範囲**: プロジェクト全体のトレーサビリティ管理

**推奨方針**: メインのトレーサビリティ管理手段として使用

##### 代替手段の比較表

| 評価軸             | A: 言語標準メタデータ | B: ソースコード内アノテーション | C: 外部マトリクス（JSON-LD） |
| ------------------ | --------------------- | ------------------------------- | ---------------------------- |
| **同期問題**       | ✅ 不要               | ✅ 不要                         | ⚠️ パス変更時のみ必要        |
| **コード変更影響** | ✅ なし               | ❌ トレース変更で再デプロイ     | ✅ なし                      |
| **検索性**         | ⚠️ プロジェクト単位   | ⚠️ 言語依存                     | ✅ JSON-LDで統一             |
| **詳細度**         | ⚠️ プロジェクト単位   | ✅ クラス・関数単位             | ✅ ファイル・クラス単位      |
| **標準化**         | ✅ 言語標準           | ⚠️ 標準化が必要                 | ✅ JSON Schema定義           |
| **ツール不要**     | ✅ 不要               | ✅ 不要                         | ⚠️ 同期ツール推奨            |
| **保守負担**       | ✅ 低                 | ⚠️ 中（頻繁な変更で高）         | ⚠️ 中                        |

##### 推奨される組み合わせ

| トレーサビリティの種類     | 推奨手段                    | 理由                                           |
| -------------------------- | --------------------------- | ---------------------------------------------- |
| **プロジェクト間依存関係** | A: 言語標準メタデータ       | 既存エコシステムとの統合                       |
| **要件-実装のトレース**    | C: 外部マトリクス           | コード変更を引き起こさない                     |
| **テスト-実装のトレース**  | C: 外部マトリクス           | 変更影響分析に必須                             |
| **主要クラスの設計意図**   | B: アノテーション（限定的） | コードレビュー時の可視性（変更頻度が低い場合） |
| **詳細なAPI対応関係**      | C: 外部マトリクス           | 頻繁な変更が予想されるため                     |

**結論**: **代替手段C（外部トレーサビリティマトリクス）をメインとし、A（言語標準）で補完する**ことで、Option 3のメリット（トレーサビリティ）を得つつ、デメリット（メタデータ同期）を最小化できる。

### ADR-001との整合性

ADR-001は「ドキュメントのデータ表現形式」として JSON を選定した。しかし、**実行可能コードはドキュメントではなく、実装そのもの**である。

この決定は ADR-001 の例外ではなく、**適用範囲の明確化**である：

| 成果物タイプ                           | JSON化            | 理由                                     |
| -------------------------------------- | ----------------- | ---------------------------------------- |
| **Requirements, Architecture, Design** | ✅ Yes            | 曖昧性があり、構造化・検証が必要         |
| **Implementation Guide, Test Plan**    | ✅ Yes            | 自然言語ベースで、曖昧性排除が価値を持つ |
| **Source Code, Test Code**             | ❌ No             | 実装言語自体が非曖昧な形式言語           |
| **DB Schema, IaC**                     | ❌ No             | 実行可能な形式言語（SQL/HCL）            |
| **Traceability Matrix**                | ✅ Yes（JSON-LD） | コードとドキュメントの対応関係を管理     |

**重要な追加**: トレーサビリティマトリクスは**JSON-LD形式で管理**することで、ADR-001の方針を活用しつつ、実行可能コードの分離を実現する。これにより：

- コード本体は実装言語で記述（Option 2）
- トレーサビリティはJSON-LDで管理（Option 3の利点を獲得）
- 両者を分離することでメタデータ同期問題を最小化

## Consequences

### Positive

1. **開発者体験の向上**
   - 通常の開発ツール・フローを使用可能
   - 学習コスト・移行コストの最小化

2. **実装の現実性**
   - AST化・逆変換の実装が不要
   - フレームワーク開発の複雑性が大幅に削減

3. **実行可能性の保証**
   - 変換プロセスなしに直接実行可能

4. **エコシステムの活用**
   - 各言語の豊富なツール群をすべて使用可能

### Negative

1. **JSON-LDのセマンティック定義が適用不可**
   - コードの意味定義には言語固有のドキュメント生成ツール（JSDoc/Sphinx など）を使用

2. **フレームワーク適用範囲に境界が生まれる**
   - 「Ukiyoueはコード以外に適用される」という認識が必要
   - ただし、これは明確な境界として望ましい

3. **言語依存のAI処理が必要**
   - コードのAI処理には言語固有のパーサー（Tree-sitter など）が必要
   - JSONの場合のような統一的な処理はできない

4. **トレーサビリティ管理に追加の仕組みが必要**
   - Option 3のような自動的なトレーサビリティは得られない
   - 代替手段の組み合わせが必要（後述のMitigationで対応）

### Mitigation

#### 1. トレーサビリティ管理

**代替手段C（外部トレーサビリティマトリクス）をメインとして採用**：

- **実装**: `traceability.json` （JSON-LD形式）でプロジェクト全体のトレーサビリティを管理
- **スキーマ**: JSON Schemaで構造を定義
- **セマンティクス**: JSON-LDで意味を定義（`@implements`, `@satisfies`, `@testedBy` など）
- **同期**: ファイルパス変更時の自動更新ツールを提供（Bun + TypeScript）

**補完**: 代替手段A（言語標準メタデータ）でプロジェクト間依存関係を管理

**限定的使用**: 代替手段B（アノテーション）は変更頻度が低い主要クラスのみ

#### 2. メタデータの扱い

- プロジェクトレベルのメタデータは `package.json`/`pyproject.toml` など言語標準形式を使用
- トレーサビリティ情報は `traceability.json` で一元管理

#### 3. コードドキュメントの扱い

- コード内ドキュメント（JSDoc/docstring など）は言語標準の形式を使用
- 必要に応じてドキュメント生成ツールでMarkdown/HTMLを生成

#### 4. セマンティック検索の代替

- コードのセマンティック検索には、GitHub Copilot・Sourcegraph などの専用ツールを活用
- トレーサビリティ検索は `traceability.json` のJSON-LD検索で実現

## Related Decisions

- **ADR-001**: データフォーマット・スキーマ定義の選定
  - 本決定はADR-001の適用範囲を明確化するもの
  - 「JSON for documents, native language for code」の原則

## References

### コード処理ツール

- **Tree-sitter**: 言語非依存のパーサー生成ツール（コードのAI処理に活用可能）
  - <https://tree-sitter.github.io/tree-sitter/>
- **Language Server Protocol (LSP)**: IDE機能の標準化
  - <https://microsoft.github.io/language-server-protocol/>

### ドキュメント生成ツール

- **JSDoc**: JavaScript用ドキュメント生成
  - <https://jsdoc.app/>
- **Sphinx**: Python用ドキュメント生成
  - <https://www.sphinx-doc.org/>
- **Doxygen**: C++/Java等マルチ言語対応ドキュメント生成
  - <https://www.doxygen.nl/>

### トレーサビリティ管理

- **OSLC (Open Services for Lifecycle Collaboration)**: ライフサイクル全体のトレーサビリティ標準
  - <https://open-services.net/>
- **ReqIF (Requirements Interchange Format)**: 要件管理の標準フォーマット
  - <https://www.omg.org/reqif/>

### 言語標準メタデータ

- **package.json**: Node.js/Bunの標準メタデータ形式
  - <https://docs.npmjs.com/cli/v10/configuring-npm/package-json>
- **pyproject.toml**: Pythonの標準メタデータ形式（PEP 518/621）
  - <https://peps.python.org/pep-0621/>
- **Cargo.toml**: Rustの標準メタデータ形式
  - <https://doc.rust-lang.org/cargo/reference/manifest.html>
