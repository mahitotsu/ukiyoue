# ADR-001: データフォーマット・スキーマ定義・セマンティック定義の選定

## Status

**承認済み** (Accepted)

## Context

### Background

Ukiyoue フレームワークが目指す「AI 時代の新しいドキュメント形式」において、最も根本的な決定は**データをどう表現するか**である。この選択は、以下の 3 つの側面に影響する：

1. **データフォーマット**: 情報をどの形式で保存・編集するか
2. **スキーマ定義**: 構造と制約をどう定義するか
3. **セマンティック定義**: 意味と関係性をどう表現するか

### Requirements

この決定は、specs/requirements.md で定義された以下のフレームワーク要件を満たす必要がある：

| 要件 ID          | 要件名                 | 関連性                             |
| ---------------- | ---------------------- | ---------------------------------- |
| **FR-AUTO-001**  | 構造化された形式の定義 | 🔴 Critical - データ形式の根幹     |
| **FR-AUTO-002**  | 自動バリデーション     | 🔴 Critical - 検証可能な形式が必須 |
| **FR-CONV-002**  | 動的な情報再構成       | 🟡 High - 構造化データが前提       |
| **FR-REUSE-001** | コンポーネント化       | 🟡 High - 再利用可能な形式         |
| **FR-CONV-001**  | セマンティック検索     | 🟡 High - 意味定義が必要           |

### Decision Criteria

| 基準               | 説明                       | 重要度      |
| ------------------ | -------------------------- | ----------- |
| **厳密な構造化**   | 曖昧さ・揺らぎの排除       | 🔴 Critical |
| **検証可能性**     | 妥当性・整合性の自動検証   | 🔴 Critical |
| **AI 可読性**      | LLM が理解・生成しやすい   | 🔴 Critical |
| **人間可読性**     | 人間も読みやすい（表示時） | 🟡 High     |
| **セマンティック** | 意味・関係性を明示的に定義 | 🟡 High     |
| **ツール支援**     | エコシステムが充実         | 🟢 Medium   |

## Options

### Option 1: JSON + JSON Schema + JSON-LD

#### Description

- **データフォーマット**: JSON（編集・保存）
- **スキーマ定義**: JSON Schema（構造・制約の定義）
- **セマンティック定義**: JSON-LD（意味・関係性の定義）
- **表示フォーマット**: Markdown/HTML（JSON から自動生成、読み取り専用）

#### Pros

- ✅ **厳密な構造化**: JSON は明確な構文規則、曖昧さゼロ
- ✅ **完全な検証**: JSON Schema で必須フィールド、型、パターン、enum 値を強制
- ✅ **AI/LLM 最適**: JSON はトークン効率が高く、LLM が最も得意とする形式
- ✅ **セマンティック対応**: JSON-LD で意味・関係性を形式的に定義可能
- ✅ **ツール支援充実**: エディタ補完、バリデータ、パーサーが豊富
- ✅ **プログラマブル**: API、自動生成、変換が容易
- ✅ **人間可読性**: Markdown への一方向生成で読みやすさを確保

#### Cons

- ❌ **直接編集の可読性**: JSON は Markdown より人間が直接読むには劣る
- ❌ **学習コスト**: JSON Schema と JSON-LD の理解が必要
- ❌ **ツール依存**: バリデーション・生成ツールの整備が必須

### Option 2: Markdown + YAML Frontmatter

#### Description

- **データフォーマット**: Markdown（本文）+ YAML Frontmatter（メタデータ）
- **スキーマ定義**: JSON Schema（YAML 部分のみ）
- **セマンティック定義**: カスタム規約

#### Pros

- ✅ **人間可読性**: Markdown は直接読み書きしやすい
- ✅ **学習コスト低**: 既存の Markdown 知識を活用可能
- ✅ **ツール支援**: エディタ、静的サイトジェネレータが豊富

#### Cons

- ❌ **構造化の弱さ**: セクション構造、リスト、表の意味が曖昧
- ❌ **検証困難**: 本文部分のバリデーションが不可能
- ❌ **揺らぎ**: フォーマットの一貫性を保証できない
- ❌ **タイポ検出不可**: 必須フィールド欠落、enum 違反を検出できない
- ❌ **整合性検証不可**: リンク切れ、循環参照、ID 重複の検出が困難
- ❌ **AI 処理困難**: LLM がセクション構造を誤解しやすい

### Option 3: YAML + JSON Schema

#### Description

- **データフォーマット**: YAML（編集・保存）
- **スキーマ定義**: JSON Schema（YAML 用に適用）
- **セマンティック定義**: カスタム規約
- **表示フォーマット**: Markdown/HTML（YAML から自動生成）

#### Pros

- ✅ **人間可読性**: YAML は JSON より読み書きしやすい
- ✅ **コメント対応**: YAML はコメントをサポート
- ✅ **検証可能**: JSON Schema で構造を検証可能

#### Cons

- ❌ **インデント依存**: 構文がインデントに依存し、エラーが起きやすい
- ❌ **型の曖昧さ**: yes/no/on/off が真偽値として解釈される
- ❌ **セマンティック定義**: 標準的な方法がない（JSON-LD は YAML 非対応）
- ❌ **ツール成熟度**: JSON より検証ツールが少ない
- ❌ **AI/LLM**: JSON ほど最適化されていない

### Option 4: TypeScript 型定義 + JSDoc

#### Description

- **データフォーマット**: TypeScript インターフェース
- **スキーマ定義**: TypeScript 型システム
- **セマンティック定義**: JSDoc コメント
- **表示フォーマット**: TypeDoc などで自動生成

#### Pros

- ✅ **型安全性**: コンパイル時型チェック
- ✅ **エディタ支援**: VSCode などで強力な補完
- ✅ **プログラミング統合**: コードと同じ言語

#### Cons

- ❌ **プログラミング知識必須**: TypeScript の学習コストが高い
- ❌ **データとコードの混在**: ドキュメント専用形式ではない
- ❌ **セマンティック定義**: 形式的な意味定義ができない
- ❌ **LLM との親和性**: JSON ほど構造化データ処理に最適化されていない
- ❌ **汎用性**: TypeScript 環境外での利用が困難

## Decision

**Option 1 (JSON + JSON Schema + JSON-LD) を採用する**

### Rationale

Decision Criteria の Critical 項目をすべて満たすのは Option 1 のみ：

1. **厳密な構造化** (Critical): JSON の明確な構文規則により、曖昧さを完全に排除
2. **検証可能性** (Critical): JSON Schema により、必須フィールド、型、enum 値、パターンを完全に検証可能
3. **AI 可読性** (Critical): JSON は LLM が最も得意とする形式であり、トークン効率も高い

Option 2 (Markdown) は構造化と検証が弱く、Option 3 (YAML) はセマンティック定義が困難、Option 4 (TypeScript) はプログラミング知識を要求し汎用性に欠ける。

また、Context で示した 5 つの要件（FR-AUTO-001, FR-AUTO-002, FR-CONV-002, FR-REUSE-001, FR-CONV-001）のすべてを満たすには、厳密な構造化（JSON）、完全な検証（JSON Schema）、形式的な意味定義（JSON-LD）の 3 つが揃っている必要がある。

人間可読性については、**Markdown を表示専用フォーマットとして使用**（JSON から一方向自動生成）することで解決する。

## Consequences

### Positive

- ✅ **完全な自動バリデーション**: 文法エラー、型エラー、制約違反を 100%検出可能
- ✅ **AI エージェント対応**: LLM による自動生成・編集・検索が高精度で実現
- ✅ **セマンティック検索**: JSON-LD により、意味ベースの高度な検索が可能
- ✅ **ツールエコシステム**: ajv、jsonld.js など成熟したライブラリを活用可能
- ✅ **動的再構成**: 構造化データにより、用途に応じた柔軟な表示が可能
- ✅ **メンテナンス性**: バリデーションにより、ドキュメント品質を自動保証

### Negative

- ❌ **学習コスト**: JSON Schema と JSON-LD の習得が必要
- ❌ **直接編集の煩雑さ**: JSON は Markdown ほど直接編集しやすくない
- ❌ **ツール依存**: バリデータ、生成ツールの整備が前提条件

### Risks

- ⚠️ **ツール開発負荷**: JSON → Markdown 変換ツールなどの開発が必要
- ⚠️ **移行コスト**: 既存 Markdown ドキュメントがある場合、JSON への変換が必要
- ⚠️ **初期コスト**: スキーマ設計、JSON-LD context 定義に時間がかかる

### Mitigation

- 💡 **段階的導入**: まず JSON Schema のみ導入し、JSON-LD は後から追加可能
- 💡 **テンプレート提供**: よくあるドキュメントタイプのテンプレートを用意
- 💡 **エディタ支援**: VSCode 拡張などで編集体験を改善
- 💡 **Markdown 共存**: 過渡期は Markdown も許容し、徐々に JSON へ移行

## Prerequisites

なし（この決定は他の ADR に依存しない最も基本的な決定）
