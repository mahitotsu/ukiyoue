# ADR-005: 実行可能コードのJSON化適用範囲

## Status

**承認済み** (Accepted)

## Context

### Background

Ukiyoue フレームワークは、ADR-001 により「JSON + JSON Schema + JSON-LD」をデータ表現形式として採用している。しかし、すべての成果物をJSON化すべきかという疑問が生じた。

特に **Layer 4: Implementation & Test** には以下の成果物が含まれる：

- **Source Code** (JavaScript/Python/Java/Go など)
- **Test Code** (同上)
- **Database Schema** (SQL DDL)
- **Infrastructure as Code** (Terraform/CloudFormation/Ansible など)

これらは**プログラミング言語・形式言語で記述される実行可能コード**であり、以下の特性を持つ：

1. **非曖昧性**: 構文が厳密に定義され、曖昧性がない
2. **実行可能性**: インタープリタ・コンパイラで直接実行可能
3. **ツールチェーン**: IDE・リンター・フォーマッタ・デバッガなどの充実したエコシステム
4. **形式言語**: 既に構造化されたデータ形式として完成している

これらをJSON化すべきか、実装言語のまま扱うべきかの決定が必要である。

### Requirements

この決定は、specs/requirements.md で定義された以下のフレームワーク要件に関連する：

| 要件 ID          | 要件名                 | 関連性                                   |
| ---------------- | ---------------------- | ---------------------------------------- |
| **FR-AUTO-001**  | 構造化された形式の定義 | プログラミング言語は既に構造化されている |
| **FR-AUTO-002**  | 自動バリデーション     | 言語パーサー・リンターで検証可能         |
| **FR-CONV-001**  | セマンティック検索     | コードはConversational要件の対象外か？   |
| **FR-REUSE-001** | コンポーネント化       | 関数・モジュールで既に実現されている     |

### Decision Criteria

| 基準                     | 説明                         | 重要度      |
| ------------------------ | ---------------------------- | ----------- |
| **非曖昧性の維持**       | 実装言語の厳密性を損なわない | 🔴 Critical |
| **実行可能性の保証**     | 実行環境で直接実行できる     | 🔴 Critical |
| **ツールチェーン活用**   | 既存開発ツールを使用可能     | 🔴 Critical |
| **JSON化の必要性**       | JSON化によるメリットがあるか | 🟡 High     |
| **フレームワーク一貫性** | ADR-001との整合性            | 🟡 High     |

## Options

### Option 1: すべてをJSON化する（抽象構文木として）

#### Description

Source Code/Test Code/DB Schema/IaCをすべてJSON形式の抽象構文木（AST）として表現し、JSON Schemaでスキーマ定義する。

#### Pros

- ✅ ADR-001との完全な一貫性
- ✅ 言語非依存の統一的なメタデータ付与
- ✅ JSON-LDによるセマンティック定義が可能

#### Cons

- ❌ AST化が極めて複雑（言語ごとにパーサー実装が必要）
- ❌ 実装者は通常のコードエディタ・IDEを使用できない
- ❌ リンター・フォーマッタ・デバッガなどのツールが使えない
- ❌ 実行前にASTから実装言語へ逆変換が必要
- ❌ コード補完・型チェックなどの開発支援が失われる

#### Evaluation

| 基準                     | 評価 | 説明                                      |
| ------------------------ | ---- | ----------------------------------------- |
| **非曖昧性の維持**       | ⚠️   | ASTは非曖昧だが、実装・保守が現実的でない |
| **実行可能性の保証**     | ❌   | 逆変換プロセスが必要                      |
| **ツールチェーン活用**   | ❌   | 既存ツールが使用不可                      |
| **JSON化の必要性**       | ❌   | 実装言語自体が既に構造化されている        |
| **フレームワーク一貫性** | ✅   | ADR-001と一貫                             |

### Option 2: 実行可能コードは実装言語で直接表現する（JSON化しない）

#### Description

Source Code/Test Code/DB Schema/IaCは、それぞれの実装言語（JavaScript/Python/SQL/HCLなど）で直接表現し、JSON化しない。Ukiyoueフレームワークの適用範囲を「曖昧性を持つ可能性のあるドキュメント」に限定する。

#### Pros

- ✅ 実装者は通常の開発ツール（IDE・リンター・フォーマッタ）を使用可能
- ✅ 実行環境で直接実行可能（変換不要）
- ✅ 言語エコシステムの全機能を活用できる
- ✅ 実装言語自体が既に非曖昧な形式言語である
- ✅ 開発者の学習コストが低い（通常の開発フローと同じ）

#### Cons

- ⚠️ ADR-001の方針からの例外が生じる
- ⚠️ JSON-LDによるセマンティック定義が適用できない
- ⚠️ フレームワーク適用範囲に境界が生まれる

#### Evaluation

| 基準                     | 評価 | 説明                               |
| ------------------------ | ---- | ---------------------------------- |
| **非曖昧性の維持**       | ✅   | 実装言語自体が非曖昧な形式言語     |
| **実行可能性の保証**     | ✅   | 実行環境で直接実行可能             |
| **ツールチェーン活用**   | ✅   | 既存ツールをすべて使用可能         |
| **JSON化の必要性**       | ✅   | 不要（既に構造化されている）       |
| **フレームワーク一貫性** | ⚠️   | 例外を設けるが、合理的な理由がある |

### Option 3: メタデータのみJSON、本体は実装言語

#### Description

コード本体は実装言語で記述し、メタデータ（作成者・バージョン・依存関係など）のみJSON+JSON Schemaで管理する。

#### Pros

- ✅ 実装言語のツールチェーンを活用可能
- ✅ メタデータはJSON-LDで意味定義できる
- ✅ ADR-001との部分的な一貫性

#### Cons

- ⚠️ メタデータとコード本体が分離される
- ⚠️ メタデータスキーマの設計が複雑化
- ⚠️ コード変更時のメタデータ同期が課題

#### Evaluation

| 基準                     | 評価 | 説明                               |
| ------------------------ | ---- | ---------------------------------- |
| **非曖昧性の維持**       | ✅   | 実装言語の非曖昧性を保持           |
| **実行可能性の保証**     | ✅   | 実行環境で直接実行可能             |
| **ツールチェーン活用**   | ✅   | 既存ツールを使用可能               |
| **JSON化の必要性**       | ⚠️   | メタデータのみ（過剰設計の可能性） |
| **フレームワーク一貫性** | ⚠️   | 部分的な一貫性                     |

## Decision

**Option 2: 実行可能コードは実装言語で直接表現する（JSON化しない）**を採用する。

### Rationale

1. **実装言語は既に非曖昧な形式言語である**
   - プログラミング言語・SQL・HCL（Terraformなど）は、厳密に定義された構文を持つ
   - JSON化しても非曖昧性は向上しない（むしろ複雑化する）

2. **実行可能性が最優先**
   - コードは実行されて初めて価値を持つ
   - 実行環境で直接実行できることが必須

3. **開発ツールチェーンの重要性**
   - IDE・リンター・フォーマッタ・デバッガ・型チェッカーなどは開発生産性に不可欠
   - これらを失うコストは、JSON化のメリットを大きく上回る

4. **Conversational要件の対象外**
   - コードは「実行されるもの」であり、「会話的に読まれるもの」ではない
   - FR-CONV-001（セマンティック検索）の優先度は低い

5. **フレームワークの適用範囲を明確化**
   - Ukiyoueは「曖昧性を排除したいドキュメント」に価値を提供する
   - 既に非曖昧な成果物には適用不要

### ADR-001との整合性

ADR-001は「ドキュメントのデータ表現形式」として JSON を選定した。しかし、**実行可能コードはドキュメントではなく、実装そのもの**である。

この決定は ADR-001 の例外ではなく、**適用範囲の明確化**である：

| 成果物タイプ                           | JSON化 | 理由                                     |
| -------------------------------------- | ------ | ---------------------------------------- |
| **Requirements, Architecture, Design** | ✅ Yes | 曖昧性があり、構造化・検証が必要         |
| **Implementation Guide, Test Plan**    | ✅ Yes | 自然言語ベースで、曖昧性排除が価値を持つ |
| **Source Code, Test Code**             | ❌ No  | 実装言語自体が非曖昧な形式言語           |
| **DB Schema, IaC**                     | ❌ No  | 実行可能な形式言語（SQL/HCL）            |

## Consequences

### Positive

1. **開発者体験の向上**
   - 通常の開発ツール・フローを使用可能
   - 学習コスト・移行コストの最小化

2. **実装の現実性**
   - AST化・逆変換の実装が不要
   - フレームワーク開発の複雑性が大幅に削減

3. **実行可能性の保証**
   - 変換プロセスなしに直接実行可能

4. **エコシステムの活用**
   - 各言語の豊富なツール群をすべて使用可能

### Negative

1. **JSON-LDのセマンティック定義が適用不可**
   - コードの意味定義には言語固有のドキュメント生成ツール（JSDoc/Sphinx など）を使用

2. **フレームワーク適用範囲に境界が生まれる**
   - 「Ukiyoueはコード以外に適用される」という認識が必要
   - ただし、これは明確な境界として望ましい

3. **言語依存のAI処理が必要**
   - コードのAI処理には言語固有のパーサー（Tree-sitter など）が必要
   - JSONの場合のような統一的な処理はできない

### Mitigation

1. **メタデータの扱い**
   - コードのメタデータ（作成者・バージョンなど）が必要な場合は、package.json/pyproject.toml など言語標準のメタデータ形式を使用

2. **コードドキュメントの扱い**
   - コード内ドキュメント（JSDoc/docstring など）は言語標準の形式を使用
   - 必要に応じてドキュメント生成ツールでMarkdown/HTMLを生成

3. **セマンティック検索の代替**
   - コードのセマンティック検索には、GitHub Copilot・Sourcegraph などの専用ツールを活用

## Related Decisions

- **ADR-001**: データフォーマット・スキーマ定義の選定
  - 本決定はADR-001の適用範囲を明確化するもの
  - 「JSON for documents, native language for code」の原則

## References

- **Tree-sitter**: 言語非依存のパーサー生成ツール（コードのAI処理に活用可能）
  - <https://tree-sitter.github.io/tree-sitter/>
- **Language Server Protocol (LSP)**: IDE機能の標準化
  - <https://microsoft.github.io/language-server-protocol/>
- **JSDoc**: JavaScript用ドキュメント生成
  - <https://jsdoc.app/>
- **Sphinx**: Python用ドキュメント生成
  - <https://www.sphinx-doc.org/>
