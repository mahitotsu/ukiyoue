# Artifact Taxonomy: Definitions

## 成果物タイプ詳細定義

このドキュメントは、Ukiyoue フレームワークで扱う42種類の成果物タイプの詳細定義を提供します。

**対象読者**: スキーマ設計者、フレームワーク開発者

## 📋 定義フォーマット

各成果物タイプは以下の項目で定義されます：

- **識別子**: 成果物の一意な識別子（例: `PM-CHARTER`）
- **目的**: なぜこの成果物が必要か
- **主な内容**: 何を含むべきか
- **入力**: どの成果物から情報を得るか
- **読者**: 誰がこの成果物を読むか
- **更新頻度**: いつ更新されるか
- **特徴**: 成果物の性質（承認文書、技術文書、実装コード等）

---

## 📋 成果物タイプ一覧

### Layer 1: ビジネス層（5種類）

#### Project Charter（プロジェクト憲章）

- **識別子**: `PM-CHARTER`
- **目的**: プロジェクトの正当性と承認を得るための文書
- **主な内容**:
  - **プロジェクトの背景**: なぜこのプロジェクトが必要か
  - **スポンサー・ステークホルダー**: 誰が承認し、誰に影響するか
  - **ハイレベルスコープ**: 何をするか/しないか（境界線）
  - **ハイレベルマイルストーン**: 主要な節目（期限は概算）
  - **予算・リソース制約**: 投資規模、人員制約
  - **リスクと前提条件**: プロジェクト承認時の仮定
- **入力**: なし（プロジェクトの起点）
- **読者**: 経営層、スポンサー、プロジェクトマネージャー
- **更新頻度**: プロジェクト開始時、プロジェクト方針の大幅変更時
- **特徴**: **承認文書**（経営判断のための要約）

#### Roadmap（ロードマップ）

- **識別子**: `PM-ROADMAP`
- **目的**: プロジェクトの時間軸とマイルストーンを管理
- **主な内容**:
  - **マイルストーン**: 主要なリリースポイント、フェーズゲート
  - **主要成果物と期限**: いつ何を完成させるか
  - **依存関係**: 前提条件、ブロッカー
  - **リスク**: スケジュールに影響する不確定要素
  - **リソース計画**: 各フェーズの人員配置
- **入力**: Project Charter（プロジェクトスコープと目標）、Test Results（品質状況に基づくスケジュール調整）
- **読者**: プロジェクトマネージャー、開発チームリーダー、ステークホルダー
- **更新頻度**: 定期的（月次/四半期）、進捗状況やテスト結果に応じて調整
- **特徴**: **スケジュール管理文書**（いつ何を達成するかの計画）

#### Risk Register（リスク登録簿）

- **識別子**: `PM-RISK`
- **目的**: プロジェクト全体のリスクと前提条件を一元管理
- **主な内容**:
  - **リスク一覧**: 識別されたリスク（ID、説明、カテゴリ）
  - **影響度と発生確率**: リスクの重大性評価（High/Medium/Low）
  - **緩和策**: 回避、軽減、転嫁、受容の戦略
  - **影響する成果物**: どのフェーズやマイルストーンに影響するか
  - **関連リスク**: リスク間の依存関係
  - **前提条件**: プロジェクト計画の前提となる仮定
- **入力**: Project Charter（初期リスクと前提条件）、Roadmap（フェーズ情報）、プロジェクト進行中の発見（設計、実装、テスト各段階での新規リスク識別）
- **読者**: プロジェクトマネージャー、リスク管理者、ステークホルダー
- **更新頻度**: プロジェクト開始時に作成、定期的レビュー（週次/月次）、新規リスク発生時（随時）
- **特徴**: **継続的管理文書**（リスクはプロジェクト全期間を通じて追跡）、**ADRと同様の性質**（プロジェクトライフサイクル全体で随時作成・更新される、特定の依存関係チェーンに固定されない成果物）

#### Business Goal（ビジネス目標）

- **識別子**: `BIZ-GOAL`
- **目的**: 測定可能なビジネス目標を定義し、達成状況を追跡
- **主な内容**:
  - **目標記述**: 何を達成したいか（売上向上、コスト削減、顧客満足度向上等）
  - **KPI**: 測定指標（メトリック、ベースライン、目標値、単位、測定方法）
  - **成功基準**: 目標達成と判断する基準
  - **優先度**: ビジネスインパクトの重要度（High/Medium/Low）
  - **カテゴリ**: 売上、コスト、品質、顧客満足等
  - **ステークホルダー**: 目標のオーナーと影響を受ける関係者
  - **関連リスク**: 目標達成を妨げるリスクへの参照
- **入力**: Project Charter（ハイレベルなビジネス目標）、Risk Register（目標に影響するリスク）
- **読者**: ビジネスアナリスト、プロダクトオーナー、経営層
- **更新頻度**: プロジェクト初期に定義、ビジネス環境変化時に見直し
- **特徴**: **測定可能な目標文書**（定性的な目標を定量的なKPIに変換）

#### User Story（ユーザーストーリー）

- **識別子**: `BIZ-STORY`
- **目的**: ユーザー視点での機能要求を簡潔に記述
- **主な内容**:
  - **ストーリー記述**: As a [役割], I want [機能], So that [価値]
  - **受け入れ基準**: Given-When-Then形式の検証可能な条件
  - **見積もり**: ストーリーポイント、実装工数見積もり
  - **ペルソナ**: 対象ユーザー像
  - **エピック**: 所属する大きな機能グループ
  - **スプリント**: 実装予定のスプリント番号
  - **関連ビジネス目標**: このストーリーがどのビジネス目標に貢献するか
- **入力**: Business Goal（達成すべきビジネス目標）、ユーザーリサーチ、ステークホルダーインタビュー
- **読者**: プロダクトオーナー、開発者、テスター
- **更新頻度**: バックログ作成時、スプリント計画時、ユーザーフィードバック時
- **特徴**: **アジャイル開発の基本単位**（開発チームが実装する最小機能単位）

### Layer 2: 要件定義（4種類）

#### Use Case（ユースケース）

- **識別子**: `REQ-UC`
- **目的**: アクターとシステムの相互作用を通じて価値を提供するシナリオを詳細に記述
- **主な内容**:
  - **ユースケース名**: 何をするユースケースか（例: Browse Menu, Place Order）
  - **目標**: このユースケースで達成したい価値（アクター視点）
  - **アクター**: システムと相互作用するユーザーロール（primary/secondary/system）
  - **スコープとレベル**: システム境界、ユースケースレベル（summary/user-goal/subfunction）
  - **事前条件**: ユースケース実行前に満たされるべき条件
  - **トリガー**: ユースケースを開始するイベント
  - **メインフロー**: 正常系の基本シナリオ（ステップ、アクター、アクション、システム応答、データ）
  - **代替フロー**: 正常系の別パターン（条件、分岐ポイント、ステップ、合流ポイント）
  - **例外フロー**: エラー処理、異常系（例外条件、トリガーポイント、解決方法）
  - **事後条件**: 成功時/失敗時の事後状態
  - **ビジネスルール**: 適用されるビジネスロジック
  - **非機能要求**: このユースケースに関連する性能・ユーザビリティ・セキュリティ要求
  - **拡張/インクルード**: 他のユースケースとの関係（extends/includes）
- **入力**: User Story（ユーザー視点の要求）、Business Goal（達成すべきビジネス目標）
- **読者**: ビジネスアナリスト、プロダクトオーナー、開発者、テスター、UI/UXデザイナー
- **更新頻度**: 要件定義段階で作成、ユーザーフィードバック時、ビジネスルール変更時
- **特徴**: **相互作用記述文書**（User Storyを詳細なシナリオに展開し、機能要件の源泉となる）

#### Functional Requirements（機能要件）

- **識別子**: `REQ-FUNC`
- **目的**: システムが「何をするか」を機能単位で明確に定義
- **主な内容**:
  - **機能一覧**: システムが提供する機能のカタログ
  - **機能要件詳細**: ID、説明、優先度、受け入れ基準
  - **関連ユーザーストーリー**: この機能がどのUser Storyを実現するか（参照）
  - **関連ユースケース**: この機能がどのUse Caseから導出されたか（参照）
  - **機能仕様詳細**: 入力、処理、出力、バリデーションルール
  - **優先度**: Must/Should/Could/Won't（MoSCoW法等）
- **入力**: Use Case（アクターとシステムの相互作用から機能を抽出）、Business Goal（達成すべき目標）
- **読者**: ビジネスアナリスト、プロダクトオーナー、開発者、テスター
- **更新頻度**: 要件定義段階で作成、機能追加・変更時、ユーザーフィードバック時
- **特徴**: **機能詳細化文書**（Use Caseのステップを実装可能な機能仕様に変換）、Use CaseとUser Storyへの参照でトレーサビリティ確保

#### Non-Functional Requirements（非機能要件）

- **識別子**: `REQ-NONFUNC`
- **目的**: システムの品質特性と制約条件を定義
- **主な内容**:
  - **性能要件**: レスポンスタイム、スループット、同時接続数
  - **セキュリティ要件**: 認証方式、暗号化、監査ログ、脆弱性対策
  - **可用性**: 稼働時間（99.9%等）、MTBF/MTTR
  - **拡張性**: スケーラビリティ、将来の成長への対応
  - **保守性**: 可読性、テスタビリティ、モジュール性
  - **互換性**: ブラウザ、OS、既存システムとの統合
  - **コンプライアンス**: 法規制、業界標準（GDPR、PCI-DSS等）
- **入力**: Business Goal（ビジネス制約と品質目標）、User Story（非機能的な要求）
- **読者**: アーキテクト、開発者、インフラエンジニア、セキュリティエンジニア
- **更新頻度**: 要件定義段階で作成、品質要件変更時、法規制変更時
- **特徴**: **品質基準文書**（機能以外のシステム品質を定量的に定義）

#### Data Dictionary（データ辞書）

- **識別子**: `REQ-DICT`
- **目的**: プロジェクト固有の用語とその属性レベルの詳細を定義し、チーム内の共通言語を確立
- **主な内容**:
  - **用語定義**: ビジネス用語の意味と説明
  - **データ型とフォーマット**: 技術的な型、表現形式、正規表現
  - **制約**: 必須/任意、一意性、最小/最大値、デフォルト値
  - **バリデーションルール**: 許容値、パターンマッチング（用語単体の制約）
  - **単純な計算ルール**: 用語に固有の導出ルール
- **入力**: User Story（登場する用語）、Use Case（使用される概念）
- **読者**: 全員（開発者、テスター、BA、ステークホルダー）
- **更新頻度**: 要件定義段階で作成、新しい用語が登場する度に追加、仕様変更時
- **特徴**: **用語辞書**（プロジェクト内での言葉の意味とフォーマットを統一、曖昧性を排除）

#### Conceptual Data Model（概念データモデル）

- **識別子**: `REQ-CONCEPT`
- **目的**: ビジネス概念（エンティティ）間の関係性を定義し、システムが扱う情報構造を可視化
- **主な内容**:
  - **概念エンティティ**: ビジネス上の重要な概念とその説明
  - **関係性**: エンティティ間の関連（1対1、1対多、多対多）と多重度
  - **エンティティ間のビジネスルール**: 複数エンティティにまたがる制約や整合性ルール
  - **状態遷移**: エンティティのライフサイクルと状態変化のルール
  - **集約と境界**: どのエンティティが主体で、どれが従属するか（Aggregate Root概念）
- **入力**: Data Dictionary（エンティティとして扱う用語）、Use Case（エンティティ間の相互作用）
- **読者**: ビジネスアナリスト、開発者、アーキテクト、ステークホルダー
- **更新頻度**: 要件定義段階で作成、ビジネスルール変更時、エンティティ追加/変更時
- **特徴**: **概念構造文書**（実装非依存、ビジネス視点でのデータ構造、Layer 3の論理データモデルへの入力）

#### Test Strategy（テスト戦略）

- **識別子**: `REQ-TESTSTRATEGY`
- **目的**: プロジェクト全体のテスト方針とリリース判定基準を定義（全テストレベルの統括）
- **主な内容**:
  - **テストレベル定義**: Unit → Integration → E2E → System Integration Test → UAT の各段階の役割
  - **品質ゲート**: 各テストレベルの合格基準、次フェーズへの移行条件
  - **リリース判定基準**: 本番リリース可否の最終判断基準（ビジネス+機能+非機能+運用）
  - **テスト環境戦略**: 開発環境、テスト環境、ステージング環境、本番環境の使い分け
  - **役割と責任**: 開発チーム、QAチーム、運用チーム、ビジネスユーザーの役割分担
  - **リスクベーステスト**: 高リスク領域の重点テスト、テスト優先順位付け
  - **自動化方針**: どのテストを自動化するか、ツール選定方針
- **入力**: Business Goal（ビジネスリスク評価）、Functional Requirements（機能範囲）、Non-Functional Requirements（品質基準）
- **読者**: プロジェクトマネージャー、テストマネージャー、QAリーダー、開発リーダー、運用マネージャー
- **更新頻度**: プロジェクト初期に作成、重大な方針変更時、リスク変化時
- **特徴**: **全体テスト統括文書**（Test Plan/SIT Plan/UAT Planの上位方針、リリース判定の基準設定）

### Layer 3: 設計（11種類）

#### Architecture Decision Record（アーキテクチャ決定記録）

- **識別子**: `ARCH-ADR`
- **目的**: 重要な技術選定の理由と経緯を記録し、将来の判断材料とする
- **主な内容**:
  - **決定内容**: 何を選択したか（技術、パターン、アプローチ）
  - **背景・コンテキスト**: なぜこの決定が必要だったか
  - **選択肢**: 検討した代替案（Pros/Cons）
  - **根拠**: なぜこの選択肢を選んだか（技術的理由、コスト、リスク）
  - **影響**: この決定が他のコンポーネントに与える影響
  - **ステータス**: Proposed/Accepted/Deprecated/Superseded
- **入力**: Non-Functional Requirements（制約と品質要件）、Runtime Architecture（技術スタック選定）、Infrastructure Architecture（インフラ選定）、Security Architecture（セキュリティ実装方式）（アーキテクチャ設計全般で発生する技術決定の記録）
- **読者**: アーキテクト、開発チームリーダー、新規参画メンバー
- **更新頻度**: 重要な技術決定時、アーキテクチャ変更時、決定の見直し時
- **特徴**: **決定の記録**（「なぜ」を残す履歴文書、後で振り返るための証拠）

#### Runtime Architecture（実行時アーキテクチャ）

- **識別子**: `ARCH-RUNTIME`
- **目的**: システムが実行時にどう動作するかの全体構造を定義
- **主な内容**:
  - **システム構成図**: コンポーネント、サービス、外部システムの配置
  - **コンポーネント構成**: マイクロサービス/モノリス、フロントエンド/バックエンド構成
  - **通信方式**: 同期/非同期、REST/gRPC/メッセージング
  - **技術スタック**: 言語、フレームワーク、ミドルウェア
  - **データフロー**: リクエスト処理の流れ、イベントフロー
  - **統合ポイント**: 外部API、SaaS、レガシーシステムとの連携
- **入力**: Architecture Decision Record（技術選定の根拠）、Functional Requirements（コンポーネント分割とデータフローの根拠）、Non-Functional Requirements（性能・拡張性要件）
- **読者**: アーキテクト、開発者、インフラエンジニア、新規参画メンバー
- **更新頻度**: 設計段階で作成、アーキテクチャ変更時、技術スタック変更時
- **特徴**: **実行時構造文書**（Non-Functional Requirementsを満たすシステム構造設計）

#### Data Model（論理データモデル）

- **識別子**: `ARCH-DATA`
- **目的**: システムが扱うデータの構造を論理的に定義（データストア非依存、実装可能な詳細レベル）
- **主な内容**:
  - **データストア種別ごとの設計**: RDB（ER図、正規化）、ドキュメントDB（コレクション構造）、キー値ストア（キー設計）、グラフDB（ノード・エッジ）等
  - **エンティティ/コレクション定義**: 技術的な観点でのデータ構造設計
  - **属性詳細定義**: 各データが持つ全属性（論理的な型、長さ、必須/任意、デフォルト値）
  - **関係性と整合性**: 参照関係、埋め込み vs 参照の選択、整合性制約の論理設計
  - **アクセスパターン設計**: クエリパターン、インデックス方針、パーティショニング方針
  - **ドメイン定義**: 共通データ型の技術的定義（メールアドレス形式、電話番号形式等）
- **入力**: Conceptual Data Model（概念エンティティを論理設計に詳細化）、Data Dictionary（属性の型と制約）、Use Case（アクセスパターンの根拠）、Functional Requirements（扱うデータの種類）、Runtime Architecture（データストア選定とアクセス方法）
- **読者**: データアーキテクト、開発者、DBA、インフラエンジニア
- **更新頻度**: 設計段階で作成、データ構造変更時、パフォーマンス要件変更時
- **特徴**: **論理データモデル**（データストア非依存だが実装可能な詳細レベル、Conceptual Data Modelを技術的に詳細化、Layer 4の物理データモデルへの入力）

#### UI/UX Specification（UI/UX 仕様）

- **識別子**: `ARCH-UI`
- **目的**: ユーザーインターフェースとユーザー体験を詳細に設計
- **主な内容**:
  - **画面遷移図**: 画面フロー、ナビゲーション構造
  - **ワイヤーフレーム**: 画面レイアウト、要素配置
  - **インタラクションデザイン**: ボタン動作、フォーム検証、エラー表示
  - **デザインガイドライン**: カラーパレット、タイポグラフィ、コンポーネント
  - **レスポンシブデザイン**: デバイス別（PC/タブレット/スマホ）のレイアウト
  - **アクセシビリティ**: WCAG準拠、スクリーンリーダー対応
- **入力**: Functional Requirements（画面で実現する機能）、Data Model（画面に表示するデータ）
- **読者**: UI/UXデザイナー、フロントエンド開発者、プロダクトオーナー
- **更新頻度**: 設計段階で作成、UI変更時、ユーザーフィードバック反映時
- **特徴**: **UI設計文書**（Functional Requirementsをユーザー視点で可視化）

#### API Specification（API 仕様）

- **識別子**: `ARCH-API`
- **目的**: システム間/コンポーネント間のインターフェースを厳密に定義
- **主な内容**:
  - **エンドポイント一覧**: URL、HTTPメソッド、概要
  - **リクエスト仕様**: パラメータ（パス/クエリ/ボディ）、型、必須/任意
  - **レスポンス仕様**: ステータスコード、レスポンスボディ、ヘッダー
  - **認証・認可**: API キー、OAuth、JWT トークン
  - **エラーハンドリング**: エラーコード、エラーメッセージフォーマット
  - **レート制限**: スロットリング、クォータ
  - **バージョニング**: API バージョン管理戦略
- **入力**: Runtime Architecture（API設計方針とアーキテクチャパターン）、Data Model（APIで扱うデータ構造）
- **読者**: API開発者、フロントエンド開発者、API利用者（内部/外部）
- **更新頻度**: API設計段階で作成、API変更時、バージョンアップ時
- **特徴**: **インターフェース契約文書**（OpenAPI/Swagger等の機械可読形式推奨）

#### Security Architecture（セキュリティアーキテクチャ）

- **識別子**: `ARCH-SECURITY`
- **目的**: システム全体のセキュリティ対策を体系的に設計
- **主な内容**:
  - **認証方式**: ユーザー認証（パスワード、MFA、SSO、生体認証）
  - **認可方式**: アクセス制御（RBAC、ABAC）、権限管理
  - **暗号化方針**: データ暗号化（保存時/転送時）、鍵管理
  - **脆弱性対策**: OWASP Top 10対策、SQLインジェクション、XSS、CSRF
  - **セキュアコーディング**: 入力検証、エスケープ、セキュアAPI使用
  - **監査ログ**: アクセスログ、操作ログ、証跡管理
  - **脅威モデリング**: 攻撃シナリオ、リスク評価
- **入力**: Non-Functional Requirements（セキュリティ要件）、Runtime Architecture（セキュリティを実装する対象システム）
- **読者**: セキュリティエンジニア、開発者、アーキテクト、監査担当者
- **更新頻度**: 設計段階で作成、セキュリティ要件変更時、脆弱性発見時
- **特徴**: **セキュリティ設計文書**（Non-Functional Requirementsのセキュリティ要件を実装方針に落とし込む）

#### Reliability Architecture（信頼性アーキテクチャ）

- **識別子**: `ARCH-RELIABILITY`
- **目的**: システムの信頼性要件を抽象的に定義（Infrastructure Architectureへのインプット）
- **主な内容**:
  - **SLO/SLI/SLA定義**: サービスレベル目標、指標、契約
  - **可用性レベル**: 目標稼働率（99.9%、99.99%等）、ダウンタイム許容値
  - **冗長化レベル**: Multi-AZ必要性、Active-Active/Active-Standby
  - **DR要件**: RPO（目標復旧時点）、RTO（目標復旧時間）
  - **容量要件**: 想定トラフィック、成長予測、ピーク対応
  - **障害許容度**: 単一障害点（SPOF）の許容範囲
- **入力**: Non-Functional Requirements（信頼性・可用性要件を抽象的に定義）
- **読者**: アーキテクト、SRE、インフラエンジニア、ビジネスオーナー
- **更新頻度**: 設計段階で作成、非機能要件変更時、ビジネス成長に応じて見直し
- **特徴**: **信頼性要件文書**（「どのくらい信頼性が必要か」を定義、ADR-005参照）

#### Infrastructure Architecture（インフラストラクチャアーキテクチャ）

- **識別子**: `ARCH-INFRA`
- **目的**: インフラストラクチャの具体的構成を設計（Reliability Architectureの具体化）
- **主な内容**:
  - **ネットワーク構成**: VPC、サブネット、ルーティング、ファイアウォール
  - **サーバー/コンテナ構成**: EC2/ECS/EKS、VM/コンテナ、サイジング
  - **Multi-AZ構成**: リージョン、アベイラビリティゾーン配置
  - **負荷分散**: ロードバランサー（ALB/NLB）、トラフィック分散
  - **Auto Scaling設計**: スケールアウト/イン条件、閾値
  - **バックアップ構成**: バックアップ戦略、世代管理、リストア手順
  - **クラウドリソース設計**: AWS/Azure/GCPサービス選定、構成図
- **入力**: Reliability Architecture（信頼性要件を具体実装）、Runtime Architecture（実行時構成に基づくインフラ）、Security Architecture（セキュアなインフラ構成）
- **読者**: インフラエンジニア、SRE、DevOpsエンジニア、アーキテクト
- **更新頻度**: 設計段階で作成、インフラ要件変更時、スケーリング要件変更時
- **特徴**: **インフラ具体設計文書**（Reliability Architectureを実現する具体的構成、ADR-005参照）

#### Observability Architecture（可観測性アーキテクチャ）

- **識別子**: `ARCH-OBSERVABILITY`
- **目的**: 監視・ログ・トレースの設計（Infrastructure Architectureの運用面）
- **主な内容**:
  - **メトリクス定義**: アプリケーションメトリクス（レイテンシ、エラー率）、インフラメトリクス（CPU、メモリ）
  - **ログフォーマット**: 構造化ログ（JSON）、ログレベル、必須フィールド
  - **ログ保持期間**: 保存期間、アーカイブ戦略
  - **トレース設計**: 分散トレーシング、スパン設計
  - **アラート設計**: アラート条件、閾値、通知先、エスカレーション
  - **ダッシュボード**: 監視ダッシュボード構成、可視化項目
  - **インシデント対応フロー**: 検知→通知→対応→事後対応
- **入力**: Runtime Architecture（監視対象のアプリケーション構造）、Infrastructure Architecture（監視対象のインフラ構成）、Reliability Architecture（監視目的とSLO/SLI）
- **読者**: SRE、運用チーム、DevOpsエンジニア、開発者
- **更新頻度**: 設計段階で作成、監視要件変更時、インシデント経験の反映時
- **特徴**: **運用監視設計文書**（システムの健全性を継続的に監視する設計、ADR-005参照）

#### DevOps Architecture（DevOps アーキテクチャ）

- **識別子**: `ARCH-DEVOPS`
- **目的**: チーム開発・リリースプロセスの全体設計（git push以降のプロセス）
- **主な内容**:
  - **ブランチ戦略**: Git Flow/GitHub Flow/Trunk-Based Development、ブランチ命名規則
  - **PR/MRプロセス**: レビュープロセス、承認フロー、マージ条件
  - **CI/CDパイプライン設計**: ビルド→テスト→デプロイフロー、各ステージの自動化範囲
  - **リリース戦略**: Blue-Green Deployment、Canary Release、Feature Flag
  - **環境管理**: dev/staging/production環境、環境間の差異管理、プロモーション戦略
  - **成果物管理**: コンテナレジストリ、パッケージレポジトリ、アーティファクト保管
  - **自動化方針**: どこまで自動化するか、手動承認ポイント
- **入力**: Runtime Architecture（CI/CD対象のシステム構成）
- **読者**: DevOpsエンジニア、開発リーダー、リリースマネージャー
- **更新頻度**: 設計段階で作成、開発プロセス変更時、ツール変更時
- **特徴**: **チーム協調プロセス設計文書**（git push以降の継続的デリバリー戦略）

#### Development Environment Architecture（開発環境アーキテクチャ）

- **識別子**: `ARCH-DEVENV`
- **目的**: ローカル開発環境と個人生産性の最大化（git push以前のプロセス）
- **主な内容**:
  - **開発ツール選定**: IDE（VS Code、IntelliJ等）、エディタ、デバッガ、プロファイラ
  - **ローカル環境構成**: Docker Compose、仮想環境、ローカル開発サーバー設定
  - **ローカルワークフロー**: コーディング→ローカルテスト→デバッグ→コミットまでの流れ
  - **デバッグ環境**: ブレークポイント設定、変数監視、ステップ実行環境
  - **依存関係管理方針**: パッケージマネージャ、ロックファイル戦略
  - **開発環境の統一方針**: チーム全体で共通化する設定、個人設定の許容範囲
- **入力**: Runtime Architecture（開発対象のシステム構成）、DevOps Architecture（チームプロセスとの整合性）
- **読者**: 開発リーダー、開発者、新規参画メンバー
- **更新頻度**: プロジェクト開始時、ツール変更時、開発プロセス改善時
- **特徴**: **個人生産性設計文書**（ローカル環境での日常作業の効率化）

#### Test Plan（テスト計画）

- **識別子**: `ARCH-TESTPLAN`
- **目的**: テスト全体の戦略とスケジュールを計画
- **主な内容**:
  - **テスト戦略**: 何をどこまでテストするか（範囲、深さ、優先度）
  - **テストレベル**:
    - **機能テスト**: ユニットテスト、統合テスト、E2Eテスト
    - **非機能テスト**: 性能テスト、セキュリティテスト、可用性テスト、運用性テスト
  - **テスト環境**: テスト用インフラ、データ、ツール
  - **リソース計画**: テスト担当者、工数、スケジュール
  - **品質基準**: テスト合格基準、カバレッジ目標
  - **リスク管理**: テストリスク、軽減策
- **入力**: Test Strategy（全体テスト方針）、Functional Requirements（機能テスト対象）、Non-Functional Requirements（非機能テスト対象）
- **読者**: テストマネージャー、QAチーム、プロジェクトマネージャー
- **更新頻度**: テスト開始前に作成、計画変更時、リスク変化時
- **特徴**: **テスト戦略文書**（Test Strategyを具体的な計画に落とし込む）

#### Test Specification（テスト仕様）

- **識別子**: `ARCH-TESTSPEC`
- **目的**: テストケースとテスト手順を詳細に定義（Test Planの詳細化）
- **主な内容**:
  - **テストケース**: ID、テスト項目、目的
  - **テスト条件**: 入力データ、前提条件
  - **テスト手順**: ステップバイステップの実行手順
  - **期待結果**: 合格判定基準
  - **テストデータ**: テスト用マスタ、トランザクションデータ
  - **トレーサビリティ**: どの要件をテストしているか（要件IDとの紐付け）
- **入力**: Test Plan（テスト戦略を詳細化）、Functional Requirements（テスト対象機能の詳細仕様）、UI/UX Specification（画面テストケース）、API Specification（APIテストケース）
- **読者**: テスター、QAエンジニア、開発者
- **更新頻度**: テスト設計段階で作成、仕様変更時、不具合修正時
- **特徴**: **テスト詳細仕様文書**（Test Planを実行可能な手順に落とし込む）

### Layer 4: 実装・テスト（11種類）

> **Note**: Layer 4の実行可能コード（Source Code/Test Code等）は実装言語で直接表現され、JSON化されません（ADR-005参照）。

#### Implementation Guide（実装ガイド）

- **識別子**: `IMPL-GUIDE`
- **目的**: 実装の品質とチーム内の一貫性を保つための開発標準
- **主な内容**:
  - **コーディング規約**: 命名規則、フォーマット、コメント規約
  - **実装パターン**: デザインパターン適用指針、アーキテクチャパターン
  - **ベストプラクティス**: 言語・フレームワーク固有の推奨事項
  - **禁止事項**: アンチパターン、避けるべきコード
  - **ライブラリ選定**: 承認済みライブラリ、使用禁止ライブラリ
  - **エラーハンドリング**: 例外処理の方針、ログ出力ルール
  - **開発環境使用ガイド**: ローカル開発サーバー起動、デバッグ方法、トラブルシューティング
  - **ブランチ・コミット規約**: ブランチ命名規則、コミットメッセージフォーマット、PR作成前チェックリスト
  - **レビュー基準**: コードレビューのチェックポイント
- **入力**: Runtime Architecture（実装対象のアーキテクチャパターン）、Security Architecture（セキュアコーディング規約）、Development Environment Architecture（ローカル開発環境での作業方法）、DevOps Architecture（ブランチ戦略、PR/レビュープロセス）
- **読者**: 開発者（全員）、新規参画メンバー
- **更新頻度**: 実装開始時に作成、知見蓄積時、チームコンセンサス変更時
- **特徴**: **開発標準文書**（複数のアーキテクチャ設計を実装レベルで統合・具体化）

#### Development Environment Configuration（開発環境設定）

- **識別子**: `IMPL-DEVENV`
- **目的**: ローカル開発環境のセットアップ自動化（個人作業環境の構築）
- **主な内容**:
  - **IDE設定ファイル**: .vscode/settings.json、.idea/、EditorConfig
  - **開発用コンテナ定義**: docker-compose.dev.yml、Dockerfile.dev、devcontainer.json
  - **ローカルサーバー設定**: 開発サーバー起動スクリプト、ホットリロード設定
  - **デバッグ設定**: launch.json、デバッガ設定、ブレークポイント設定例
  - **環境変数テンプレート**: .env.example、ローカル開発用の環境変数説明
  - **依存関係固定**: package-lock.json、poetry.lock、Gemfile.lock
  - **セットアップスクリプト**: bootstrap.sh、環境構築自動化スクリプト
  - **READMEと手順書**: 開発環境構築手順、トラブルシューティング
- **入力**: Development Environment Architecture（開発環境設計を実装に落とす）、Runtime Architecture（技術スタック情報）、Repository Configuration（品質ツール設定との整合性）
- **読者**: 開発者（全員）、新規参画メンバー、オンボーディング担当者
- **更新頻度**: プロジェクト開始時、ツール追加時、環境変更時、継続的に更新
- **特徴**: **ローカル環境実装コード**（開発者が即座にローカル開発を開始できる環境の自動構築）

#### Physical Data Model（物理データモデル）

- **識別子**: `IMPL-PHYSICAL-DATA`
- **目的**: データストアの物理実装を定義（論理データモデルの実装コード化、データストア固有）
- **主な内容**:
  - **RDB**: DDL（CREATE TABLE文）、物理テーブル定義、主キー・外部キー、インデックス、パーティション、ストレージ設計
  - **ドキュメントDB**: コレクションスキーマ、インデックス定義、シャーディングキー（MongoDB等）
  - **キー値ストア**: キー命名規則、データ構造（Hash/Set/List）、TTL設定、永続化設定（Redis等）
  - **検索エンジン**: インデックスマッピング、アナライザー設定、シャード・レプリカ設計（Elasticsearch等）
  - **グラフDB**: ノードラベル、リレーションシップタイプ、プロパティ定義、インデックス（Neo4j等）
  - **メッセージキュー**: トピック/キュー定義、パーティション設計、保持期間（Kafka、RabbitMQ等）
  - **データストア固有の最適化**: パフォーマンスチューニング、キャパシティプランニング
- **入力**: Data Model（論理データモデルを特定データストアで物理実装）
- **読者**: DBA、バックエンド開発者、インフラエンジニア、データエンジニア
- **更新頻度**: 実装段階で作成、スキーマ変更時、パフォーマンスチューニング時
- **特徴**: **物理データモデル（実装コード）**（論理データモデルを実行可能な定義として実装、データストア固有の最適化を含む）

#### Infrastructure as Code（インフラストラクチャコード）

- **識別子**: `IMPL-IAC`
- **目的**: インフラストラクチャの実装（Infrastructure Architectureのコード化）
- **主な内容**:
  - **IaCコード**: Terraform、CloudFormation、Pulumi等の宣言的コード
  - **構成管理**: Ansible、Chef、Puppet等の構成管理ツール
  - **Kubernetesマニフェスト**: Deployment、Service、Ingress等のリソース定義
  - **環境別設定**: dev/staging/prod環境の変数管理
  - **モジュール設計**: 再利用可能なインフラモジュール
  - **バージョン管理**: インフラコードのGit管理、変更履歴
- **入力**: Infrastructure Architecture（コード化対象のインフラ設計）
- **読者**: インフラエンジニア、SRE、DevOpsエンジニア
- **更新頻度**: 実装段階で作成、継続的に更新、インフラ変更の都度
- **特徴**: **インフラ実装コード**（Infrastructure Architectureを実行可能コードで表現）

#### CI/CD Pipeline Definition（CI/CDパイプライン定義）

- **識別子**: `IMPL-PIPELINE`
- **目的**: CI/CDパイプラインの実装（DevOps Architectureの具体化）
- **主な内容**:
  - **パイプライン定義**: GitHub Actions、GitLab CI、Jenkins、Azure DevOps等のYAML/設定
  - **ビルドステージ**: コンパイル、依存関係解決、成果物生成
  - **テストステージ**: ユニットテスト、統合テスト、E2Eテスト実行
  - **デプロイステージ**: 環境別デプロイ、承認フロー
  - **環境変数・シークレット管理**: 機密情報の安全な管理
  - **通知設定**: ビルド失敗時の通知、Slack/メール連携
- **入力**: DevOps Architecture（パイプライン設計方針）
- **読者**: DevOpsエンジニア、開発者、リリース担当者
- **更新頻度**: 実装段階で作成、パイプライン変更時、デプロイ戦略変更時
- **特徴**: **パイプライン実装コード**（DevOps Architectureを自動化パイプラインとして実装）

#### Repository Configuration（リポジトリ設定）

- **識別子**: `IMPL-REPO`
- **目的**: リポジトリ基盤とチーム品質ゲートの設定（git push以降の品質保証）
- **主な内容**:
  - **リポジトリ設定**: .github/（GitHub Actions、PR template、Issue template）、.gitlab-ci.yml
  - **品質ゲート**: pre-commit hooks、commit-msg hooks、lint設定、フォーマッター設定（.eslintrc、.prettierrc等）
  - **ブランチ保護ルール**: mainブランチ保護、レビュー必須設定、ステータスチェック必須化
  - **依存関係管理自動化**: Dependabot、Renovate Bot設定
  - **パッケージマニフェスト**: package.json、requirements.txt、go.mod、pom.xml
  - **コンテナレジストリ設定**: Docker Hub、ECR、GCR、ACR
  - **アーティファクトリポジトリ**: Artifactory、Nexus、GitHub Packages
- **入力**: DevOps Architecture（リポジトリ戦略とブランチ戦略）、Development Environment Architecture（品質ツール選定）
- **読者**: DevOpsエンジニア、開発者、リポジトリ管理者
- **更新頻度**: プロジェクト開始時、ツール変更時、依存関係更新時
- **特徴**: **リポジトリ基盤設定**（開発の起点となる設定ファイル群）

#### Monitoring & Logging Configuration（監視・ログ設定）

- **識別子**: `IMPL-MONITORING`
- **目的**: 監視・ログシステムの実装設定（Observability Architectureの具体化）
- **主な内容**:
  - **監視ツール設定**: Prometheus、Grafana、Datadog、New Relic設定
  - **ログ収集パイプライン**: Fluentd、Logstash、Filebeat設定
  - **アラートルール**: アラート条件、閾値、通知ルール
  - **ダッシュボード定義**: Grafanaダッシュボード、可視化設定
  - **ログ転送設定**: CloudWatch Logs、ELK Stack、Splunk
  - **トレーシング設定**: Jaeger、Zipkin、AWS X-Ray
- **入力**: Observability Architecture（監視設計を実装に落とす）
- **読者**: SRE、運用チーム、DevOpsエンジニア
- **更新頻度**: 実装段階で作成、監視要件変更時、アラート調整時
- **特徴**: **監視実装設定**（Observability Architectureを実際の監視システムとして実装）

#### Source Code（ソースコード）

- **識別子**: `IMPL-CODE`
- **目的**: システムの実装コード（複数の設計を統合実装）
- **主な内容**:
  - **アプリケーションコード**: ビジネスロジック、ドメインモデル
  - **フレームワークコード**: Webフレームワーク、ORMマッピング
  - **ライブラリ**: 外部ライブラリの統合、ラッパー
  - **設定ファイル**: アプリケーション設定、環境変数
  - **スクリプト**: ビルドスクリプト、マイグレーションスクリプト
- **入力**: Functional Requirements（機能実装）、Implementation Guide（実装規約）、UI/UX Specification（画面実装）、API Specification（API実装）、Physical Data Model（データアクセス実装）
- **読者**: 開発者、保守担当者、コードレビュアー
- **更新頻度**: 実装段階で作成、継続的に更新（毎日）
- **特徴**: **実装コード**（最も多くの設計情報を統合する成果物、品質はTest Resultsで検証）

#### Test Code（テストコード）

- **識別子**: `IMPL-TESTCODE`
- **目的**: 自動テストの実装コード（Test Specificationの自動化）
- **主な内容**:
  - **ユニットテスト**: 関数・メソッド単位のテスト（JUnit、pytest、Jest等）
  - **統合テスト**: コンポーネント間連携テスト
  - **E2Eテスト**: ユーザーシナリオテスト（Selenium、Cypress、Playwright等）
  - **テストヘルパー**: テストユーティリティ、モック、スタブ
  - **テストデータ生成**: ファクトリー、フィクスチャ
- **入力**: Test Specification（テストケースを自動化）、Source Code（テスト対象コード）
- **読者**: 開発者、QAエンジニア、テスト担当者
- **更新頻度**: 実装と並行して作成、継続的に更新（TDD/BDD）
- **特徴**: **テスト自動化コード**（Source Codeが正しいことを検証、CI/CDパイプラインで実行）

#### Test Results（テスト結果）

- **識別子**: `IMPL-TESTRESULT`
- **目的**: テスト実行結果と品質状況を記録・可視化
- **主な内容**:
  - **テスト実行結果**: 合格/不合格、成功率、実行時間
  - **カバレッジレポート**: コードカバレッジ、ブランチカバレッジ
  - **不具合一覧**: バグレポート、優先度、ステータス
  - **品質メトリクス**: 欠陥密度、修正コスト、テスト効率
  - **トレンド分析**: 品質の推移、リグレッション検知
- **入力**: Test Code実行結果（品質評価の根拠）
- **読者**: テストマネージャー、プロジェクトマネージャー、開発者、QAチーム
- **更新頻度**: テスト実行の都度（CI/CD実行時、定期テスト時）
- **特徴**: **品質評価文書**（システムの品質状況を可視化、リリース判断の根拠）

#### Source Code Documentation（ソースコードドキュメント）

- **識別子**: `IMPL-CODEDOC`
- **目的**: ソースコードの構造と実装詳細を説明（保守性向上）
- **主な内容**:
  - **アーキテクチャ図**: クラス図、コンポーネント図、パッケージ構成
  - **シーケンス図**: 処理フロー、メソッド呼び出し順序
  - **インラインコメント**: コード内のドキュメンテーションコメント（JSDoc、Javadoc、docstring等）
  - **自動生成APIドキュメント**: Swagger UI、Javadoc、Sphinx等
  - **READMEファイル**: プロジェクト構成、ビルド方法、開発ガイド
  - **設計意図**: なぜこの実装にしたか（複雑なロジックの説明）
- **入力**: Source Code（ドキュメント化対象のコード）
- **読者**: 開発者、保守担当者、新規参画メンバー、外部開発者（API利用者）
- **更新頻度**: 実装と並行して作成、コード変更時、リファクタリング時
- **特徴**: **コード説明文書**（Source Codeを理解するためのドキュメント）

### Layer 5: 運用（4種類）

#### Deployment Guide（デプロイガイド）

- **識別子**: `OPS-DEPLOY`
- **目的**: システムのデプロイ手順を明確化（リリース作業の標準化）
- **主な内容**:
  - **環境構築手順**: 新規環境のセットアップ、前提条件
  - **デプロイ手順**: ステップバイステップのデプロイ作業
  - **設定項目**: 環境変数、設定ファイル、パラメータ
  - **検証手順**: デプロイ後の動作確認、ヘルスチェック
  - **ロールバック手順**: 問題発生時の切り戻し方法
  - **デプロイチェックリスト**: 作業前確認事項、作業後確認事項
- **入力**: Infrastructure as Code（デプロイ対象のインフラ）、CI/CD Pipeline Definition（デプロイ自動化の手順）、Test Results（品質確認されたシステムのデプロイ手順）
- **読者**: DevOpsエンジニア、リリース担当者、運用担当者
- **更新頻度**: デプロイ準備時に作成、インフラ変更時、デプロイ戦略変更時
- **特徴**: **リリース手順書**（テスト完了後、本番環境へのデプロイ手順を文書化）

#### Operations Manual（運用マニュアル）

- **識別子**: `OPS-MANUAL`
- **目的**: システムの日常運用手順を提供（安定運用の基盤）
- **主な内容**:
  - **監視項目**: 監視対象メトリクス、正常範囲、異常検知基準
  - **日次運用**: 日次チェック項目、定期作業
  - **バックアップ手順**: バックアップ実行、確認、世代管理
  - **リストア手順**: バックアップからの復元手順
  - **定期メンテナンス**: パッチ適用、証明書更新、ログローテーション
  - **運用連絡先**: エスカレーション先、サポート窓口
- **入力**: Deployment Guide（デプロイ後の運用開始）、Monitoring & Logging Configuration（監視対象と手順）
- **読者**: 運用担当者、SRE、サポート担当者
- **更新頻度**: 運用開始時に作成、運用知見蓄積時、システム変更時
- **特徴**: **日常運用手順書**（Observability ArchitectureとMonitoring Configurationを運用レベルで実践）

#### Incident Response Guide（インシデント対応ガイド）

- **識別子**: `OPS-INCIDENT`
- **目的**: 障害発生時の対応手順を定義（迅速な復旧）
- **主な内容**:
  - **インシデント定義**: 重大度レベル（Critical/High/Medium/Low）
  - **エスカレーションフロー**: 連絡体制、エスカレーション基準
  - **初動対応**: 障害検知時の第一アクション、影響範囲特定
  - **復旧手順**: 一時復旧（Workaround）、恒久対応
  - **コミュニケーション**: ステークホルダーへの報告、ユーザーへの通知
  - **事後対応**: ポストモーテム、再発防止策、ドキュメント更新
- **入力**: Observability Architecture（障害検知の仕組み）、Operations Manual（通常運用との違い）
- **読者**: 運用担当者、SRE、サポート担当者、オンコール担当者
- **更新頻度**: 運用開始時に作成、インシデント経験時、エスカレーションフロー変更時
- **特徴**: **障害対応手順書**（Observability Architectureのアラートに対応する手順、Reliability Architectureの目標達成に貢献）

#### Troubleshooting Guide（トラブルシューティングガイド）

- **識別子**: `OPS-TROUBLESHOOT`
- **目的**: 問題発生時の診断と解決方法を体系化（運用効率化）
- **主な内容**:
  - **よくある問題**: 頻発する問題、既知の問題
  - **症状と原因**: 症状から原因を特定する診断フロー
  - **診断方法**: ログ確認、メトリクス確認、コマンド実行
  - **解決手順**: ステップバイステップの対処方法
  - **FAQ**: よくある質問と回答
  - **エスカレーション判断**: どの段階で開発チームにエスカレートするか
- **入力**: Source Code Documentation（実装詳細の理解）、Incident Response Guide（障害事例とパターン）
- **読者**: 運用担当者、サポート担当者、開発者、新規運用メンバー
- **更新頻度**: 運用中に継続的に更新（インシデント経験、FAQ追加時）
- **特徴**: **問題解決ナレッジベース**（運用経験を蓄積、Monitoring Configurationの補完情報）

### Layer 6: 検証（6種類）

#### System Integration Test Plan（システム統合テスト計画）

- **識別子**: `VERIFY-SIT-PLAN`
- **目的**: システム全体の技術的統合テスト戦略を計画（E2E + デプロイ + 運用 + 障害対応）
- **主な内容**:
  - **テスト戦略**: E2Eシナリオ、デプロイ、運用、障害対応の技術的統合検証方針
  - **テストスコープ**:
    - **E2Eシナリオテスト**: 本番相当環境でのエンドツーエンド業務フロー検証
    - **デプロイテスト**: デプロイ手順の実行可能性、ロールバック確認
    - **運用テスト**: 日常運用手順の実行可能性、バックアップ/リストア検証
    - **障害対応テスト**: 障害シミュレーション、復旧手順検証、エスカレーションフロー確認
    - **トラブルシューティングテスト**: 診断手順の有効性、FAQ網羅性
  - **テスト環境**: 本番相当環境（ステージング/プリプロダクション）
  - **リソース計画**: QAチーム、運用チーム、DevOpsチーム参加、スケジュール
  - **合格基準**: 技術的統合検証の合格基準、UAT移行条件
  - **リスク管理**: 技術的統合リスク、軽減策
- **入力**: Test Strategy（全体テスト戦略）、Functional Requirements（E2Eシナリオ定義）、Non-Functional Requirements（非機能検証範囲）
- **読者**: テストマネージャー、QAリーダー、運用マネージャー、プロジェクトマネージャー
- **更新頻度**: 要件確定後に作成開始、実装進捗に応じて詳細化
- **特徴**: **技術統合テスト戦略文書**（実装完了後の技術的統合検証計画、UAT前の品質ゲート）

#### System Integration Test Specification（システム統合テスト仕様）

- **識別子**: `VERIFY-SIT-SPEC`
- **目的**: システム統合テストの詳細なテストケースと実施手順を定義
- **主な内容**:
  - **E2Eシナリオテストケース**: 本番相当環境での業務フロー全体検証、データ整合性確認
  - **デプロイテストケース**: Deployment Guide全手順の実行テスト、エラーハンドリング、ロールバックシナリオ
  - **運用テストケース**: Operations Manual全手順の検証、バックアップ/リストア実施、監視動作確認
  - **障害対応シナリオ**: Incident Response Guide検証シナリオ、障害注入（Chaos Engineering）、復旧時間測定
  - **トラブルシューティング検証**: Troubleshooting Guide診断フロー実行、問題再現と解決確認
  - **テスト手順**: ステップバイステップの実施手順、チェックリスト
  - **期待結果**: 各テストケースの合格判定基準
  - **トレーサビリティ**: 機能要件・運用ドキュメントとテストケースの紐付け
- **入力**: System Integration Test Plan（テスト戦略を詳細化）、Functional Requirements（E2Eテストケース作成）、Deployment Guide、Operations Manual、Incident Response Guide、Troubleshooting Guide（テスト対象）
- **読者**: テスター、QAエンジニア、運用チーム、DevOpsエンジニア
- **更新頻度**: SIT Plan確定後に作成、運用ドキュメント完成後に詳細化
- **特徴**: **技術統合テスト詳細化文書**（SIT Planを実行可能なテストケースに落とし込む）

#### System Integration Test Results（システム統合テスト結果）

- **識別子**: `VERIFY-SIT-RESULT`
- **目的**: システム統合テストの実施結果を記録（UAT移行判断の根拠）
- **主な内容**:
  - **E2Eシナリオテスト結果**: 業務フロー全体の検証結果、データ整合性確認結果、性能測定
  - **デプロイテスト結果**: Deployment Guide実行結果、手順の正確性、所要時間、問題点
  - **運用テスト結果**: Operations Manual検証結果、手順の実行可能性、バックアップ/リストア成功確認
  - **障害対応テスト結果**: Incident Response Guide検証結果、復旧時間、エスカレーション動作確認
  - **トラブルシューティング検証結果**: Troubleshooting Guide有効性評価、不足情報の特定
  - **不具合一覧**: 機能不備、運用ドキュメントの不備、手順のエラー、改善提案
  - **UAT移行可否判断**: 技術的品質確認、運用準備度評価、UAT実施可能性判断
- **入力**: System Integration Test Specification（テストケース実行）、Functional Requirements（機能要件トレーサビリティ）、Deployment Guide、Operations Manual、Incident Response Guide、Troubleshooting Guide（テスト対象）
- **読者**: テストマネージャー、QAリーダー、運用マネージャー、プロジェクトマネージャー
- **更新頻度**: SIT実施時、再テスト時
- **特徴**: **技術統合テスト結果文書**（技術的品質と運用準備度を検証、UAT移行の品質ゲート）

#### UAT Plan（ユーザー受入テスト計画）

- **識別子**: `VERIFY-UAT-PLAN`
- **目的**: ビジネスユーザーによる受入テスト戦略を計画（ビジネス目標達成度評価）
- **主な内容**:
  - **テスト戦略**: ビジネスゴール達成度評価、ビジネスユーザー主導の検証方針
  - **テストスコープ**:
    - **ビジネス目標検証**: ビジネス課題解決の確認、KPI達成度測定、ROI評価
    - **ユーザーシナリオ検証**: 実際の業務フローでの使用感、UI/UX評価
    - **受入基準チェック**: Business Goal/Functional Requirementsの充足確認
  - **テスト環境**: 本番相当環境（SIT合格済み環境）
  - **リソース計画**: ビジネスユーザー、プロダクトオーナー、QAサポート、スケジュール
  - **合格基準**: ビジネス目標達成確認、ユーザー受入基準、本番リリース可否判断基準
  - **リスク管理**: ビジネスインパクトリスク、ユーザー受入リスク、軽減策
- **入力**: Test Strategy（全体テスト戦略）、Business Goal（ビジネス目標定義）、Functional Requirements（機能要件受入基準）
- **読者**: ビジネスユーザー、プロダクトオーナー、プロジェクトマネージャー、テストマネージャー
- **更新頻度**: 要件確定後に作成開始、SIT進捗に応じて詳細化
- **特徴**: **ビジネス受入テスト戦略文書**（ビジネスユーザー主導の最終検証計画、リリース判断の鍵）

#### UAT Specification（ユーザー受入テスト仕様）

- **識別子**: `VERIFY-UAT-SPEC`
- **目的**: UATの詳細なテストケースと実施手順を定義
- **主な内容**:
  - **ビジネス目標検証テストケース**: ビジネス課題解決確認、KPI測定方法、ROI評価シナリオ
  - **ユーザーシナリオテストケース**: 実業務フロー検証、役割別シナリオ、エッジケース確認
  - **受入基準チェックリスト**: Business Goal/Functional Requirements項目別チェック
  - **テスト手順**: ビジネスユーザー向けの平易な手順書、サポート体制
  - **期待結果**: ビジネス観点での合格判定基準
  - **トレーサビリティ**: ビジネス目標・機能要件とテストケースの紐付け
- **入力**: UAT Plan（テスト戦略を詳細化）、Business Goal（ビジネス目標テストケース作成）、Functional Requirements（機能受入テストケース作成）
- **読者**: ビジネスユーザー、プロダクトオーナー、QAサポート、テストマネージャー
- **更新頻度**: UAT Plan確定後に作成、SIT完了後に最終化
- **特徴**: **ビジネス受入テスト詳細化文書**（UAT Planを実行可能なテストケースに落とし込む）

#### UAT Results（ユーザー受入テスト結果）

- **識別子**: `VERIFY-UAT-RESULT`
- **目的**: UATの実施結果を記録（本番リリース判断の最終根拠）
- **主な内容**:
  - **ビジネス目標達成度評価**: ビジネス課題解決確認結果、KPI達成度、ROI試算、投資判断材料
  - **ユーザーシナリオ検証結果**: 実業務での使用感評価、UI/UX評価、改善提案
  - **受入基準達成状況**: Business Goal/Functional Requirements充足確認
  - **不具合一覧**: ビジネス目標未達、機能不備、ユーザビリティ問題
  - **本番リリース判断**: ビジネス観点での最終承認、リリース可否、条件付き承認
- **入力**: UAT Specification（テストケース実行）、Business Goal（ビジネス目標トレーサビリティ）、Functional Requirements（機能要件トレーサビリティ）
- **読者**: ビジネスユーザー、プロダクトオーナー、プロジェクトマネージャー、ステークホルダー、経営層
- **更新頻度**: UAT実施時、再テスト時
- **特徴**: **ビジネス受入テスト結果文書**（ビジネス目標達成度を検証、本番リリースの最終判断根拠）

---

---

## 📊 成果物タイプサマリー

| レイヤー         | 成果物数 | 主な役割                       |
| ---------------- | -------- | ------------------------------ |
| プロジェクト管理 | 2        | 方向性と計画                   |
| 要件定義         | 4        | 何を実現するか + テスト戦略    |
| 設計             | 11       | どう実現するか                 |
| 実装・テスト     | 13       | コードと品質保証               |
| 運用             | 4        | システムの継続的な稼働         |
| 検証             | 6        | システム統合検証とビジネス受入 |
| **合計**         | **40**   | プロジェクトライフサイクル全体 |

## 関連ドキュメント

- [artifact-overview.md](artifact-overview.md) - 成果物分類の全体像
- [artifact-relationships.md](artifact-relationships.md) - 成果物間の依存関係とデータフロー
- [ADR-005](design-decisions/005-executable-code-representation.md) - 実行可能コードのJSON化適用範囲（Layer 4に関連）
