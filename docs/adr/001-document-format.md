# ADR-001: ドキュメント形式の選定

## ステータス

承認済み

## コンテキスト

### 背景

Ukiyoueフレームワークは、AI時代のプロジェクトドキュメント管理を革新することを目指しています。その核心となるのが、ドキュメントをどの形式で記述・保存するかという決定です。

この決定は、フレームワーク全体のアーキテクチャに影響を与える最も基本的かつ重要な選択です。

### 問題

AIエージェントと人間が協働してドキュメントを作成・管理するためには、以下の要件を満たす形式が必要です：

1. **AI可読性**: LLMが解析・生成しやすい
2. **構造化**: 厳密なバリデーションが可能
3. **セマンティック対応**: 意味・関係性を定義できる
4. **人間可読性**: 最終的に人間が理解できる
5. **エコシステム**: 豊富なツール・ライブラリが存在する

### 要求事項

```yaml
必須要件:
  - AIによる自動生成・解析が容易
  - 構造検証（スキーマバリデーション）が可能
  - セマンティック定義（JSON-LD等）に対応
  - プログラマブル（プログラムで処理しやすい）
  - エコシステムが成熟している

望ましい要件:
  - 人間が直接編集可能
  - Gitによるバージョン管理との親和性
  - 軽量（ファイルサイズが小さい）
  - 広く普及している

制約条件:
  - 複雑すぎない（学習コストが高すぎない）
  - 特定ベンダーに依存しない
  - オープンスタンダード
```

## 決定

### 選定結果

**採用**: JSON

**理由**: JSONは、AI可読性・構造化・セマンティック対応・エコシステムのすべてにおいて最もバランスが良く、Ukiyoueの要件を最も満たす形式です。

### 評価基準

| 基準               | 重み   | 説明                           |
| ------------------ | ------ | ------------------------------ |
| AI可読性           | 🔴🔴🔴 | LLMによる解析・生成の容易さ    |
| 構造検証           | 🔴🔴🔴 | スキーマバリデーションの厳密さ |
| セマンティック対応 | 🔴🔴🔴 | 意味定義の表現力               |
| エコシステム       | 🔴🔴   | ツール・ライブラリの充実度     |
| 人間可読性         | 🔴🔴   | 直接編集のしやすさ             |
| Git親和性          | 🔴     | 差分管理のしやすさ             |

### 検討した選択肢

#### Option A: JSON

**概要**: JavaScript Object Notation。シンプルで広く普及しているデータ交換フォーマット。

**長所**:

- ✅ LLMによる生成・解析が極めて容易（トークン効率が良い）
- ✅ JSON Schemaによる厳密な構造検証が可能
- ✅ JSON-LDによるセマンティック定義に対応
- ✅ エコシステムが圧倒的に充実（ライブラリ、ツール、IDE支援）
- ✅ プログラミング言語を問わず扱いやすい
- ✅ W3C標準（JSON-LD）に対応

**短所**:

- ❌ 人間が直接編集するには冗長（括弧、カンマ、引用符が多い）
- ❌ コメントが書けない（標準仕様では）
- ❌ Gitの差分が見づらい場合がある

**評価**:

| 基準               | スコア     | コメント                                 |
| ------------------ | ---------- | ---------------------------------------- |
| AI可読性           | ⭐⭐⭐⭐⭐ | LLMのトークン効率が最良                  |
| 構造検証           | ⭐⭐⭐⭐⭐ | JSON Schema (Draft 2020-12) が極めて強力 |
| セマンティック対応 | ⭐⭐⭐⭐⭐ | JSON-LD 1.1 がW3C標準                    |
| エコシステム       | ⭐⭐⭐⭐⭐ | 圧倒的な普及率とツール群                 |
| 人間可読性         | ⭐⭐⭐     | 可読だが編集性は低い                     |
| Git親和性          | ⭐⭐⭐     | フォーマッタ利用で改善可能               |

#### Option B: YAML

**概要**: YAML Ain't Markup Language。人間可読性を重視したデータシリアライゼーション形式。

**長所**:

- ✅ 人間が直接編集しやすい（インデントベース、引用符不要）
- ✅ コメントが書ける
- ✅ Gitの差分が比較的見やすい
- ✅ CI/CD設定など、開発者に馴染み深い

**短所**:

- ❌ LLMによる生成・解析がJSONより難しい（インデントの扱い）
- ❌ スキーマバリデーションが弱い（JSON Schemaほど厳密でない）
- ❌ セマンティック定義の標準がない（JSON-LD相当の仕様なし）
- ❌ パース結果が実装依存（YAML 1.1 vs 1.2 の非互換）
- ❌ 型の自動変換が曖昧（`yes` が `true` になる等）

**評価**:

| 基準               | スコア     | コメント                      |
| ------------------ | ---------- | ----------------------------- |
| AI可読性           | ⭐⭐⭐     | インデント処理が複雑          |
| 構造検証           | ⭐⭐       | JSON Schemaを流用できるが弱い |
| セマンティック対応 | ⭐         | 標準的な仕様がない            |
| エコシステム       | ⭐⭐⭐     | 充実しているが偏りあり        |
| 人間可読性         | ⭐⭐⭐⭐⭐ | 最も編集しやすい              |
| Git親和性          | ⭐⭐⭐⭐   | 差分が見やすい                |

#### Option C: TOML

**概要**: Tom's Obvious, Minimal Language。設定ファイル向けのシンプルな形式。

**長所**:

- ✅ 人間が直接編集しやすい
- ✅ コメントが書ける
- ✅ 型が明確
- ✅ ネストが浅い設定に適している

**短所**:

- ❌ LLMによる生成・解析がやや難しい（構文が独特）
- ❌ スキーマバリデーションの標準がない
- ❌ セマンティック定義の仕組みがない
- ❌ 深いネスト構造の表現が冗長
- ❌ エコシステムが限定的（主にRust, Go界隈）
- ❌ 複雑なデータ構造には不向き

**評価**:

| 基準               | スコア   | コメント                 |
| ------------------ | -------- | ------------------------ |
| AI可読性           | ⭐⭐     | 構文が特殊で学習コスト高 |
| 構造検証           | ⭐       | 標準的な仕様がない       |
| セマンティック対応 | ⭐       | 対応なし                 |
| エコシステム       | ⭐⭐     | 設定ファイル用途に限定   |
| 人間可読性         | ⭐⭐⭐⭐ | シンプルな構造では優秀   |
| Git親和性          | ⭐⭐⭐⭐ | 差分が見やすい           |

#### Option D: XML

**概要**: Extensible Markup Language。古典的だが強力な構造化文書形式。

**長所**:

- ✅ スキーマバリデーションが強力（XSD, RELAX NG）
- ✅ セマンティック技術が成熟（RDF/XML, OWL）
- ✅ エコシステムが非常に充実（企業向け）
- ✅ 名前空間によるモジュール化が可能

**短所**:

- ❌ LLMのトークン効率が悪い（冗長な構文）
- ❌ 人間が直接編集するには冗長すぎる
- ❌ モダンな開発環境との親和性が低い
- ❌ JSONと比べてプログラムでの扱いが複雑
- ❌ 重い（ファイルサイズが大きい）

**評価**:

| 基準               | スコア     | コメント                |
| ------------------ | ---------- | ----------------------- |
| AI可読性           | ⭐⭐       | トークン効率が悪い      |
| 構造検証           | ⭐⭐⭐⭐⭐ | XSDが非常に強力         |
| セマンティック対応 | ⭐⭐⭐⭐   | RDF/XMLなど成熟している |
| エコシステム       | ⭐⭐⭐⭐   | 企業向けには充実        |
| 人間可読性         | ⭐         | 冗長で読みづらい        |
| Git親和性          | ⭐⭐       | 差分が見づらい          |

#### Option E: Markdown

**概要**: 軽量マークアップ言語。技術文書やREADMEで広く使われている。

**長所**:

- ✅ 人間が直接編集しやすい（プレーンテキスト）
- ✅ Gitの差分が非常に見やすい
- ✅ LLMが生成しやすい（自然言語ベース）
- ✅ GitHub等でのレンダリング対応
- ✅ 軽量（ファイルサイズが小さい）

**短所**:

- ❌ 構造検証が弱い（標準的なスキーマがない）
- ❌ セマンティック定義の仕組みがない
- ❌ プログラムによる解析が困難（パーサーが複雑）
- ❌ 厳密なデータ構造の表現に不向き
- ❌ フレーバー間の非互換（CommonMark, GFM, etc.）
- ❌ ネストした構造の表現が限定的

**評価**:

| 基準               | スコア     | コメント               |
| ------------------ | ---------- | ---------------------- |
| AI可読性           | ⭐⭐⭐⭐   | 生成は容易だが解析は難 |
| 構造検証           | ⭐         | 標準的なスキーマなし   |
| セマンティック対応 | ⭐         | 仕組みがない           |
| エコシステム       | ⭐⭐⭐     | ドキュメント用途に限定 |
| 人間可読性         | ⭐⭐⭐⭐⭐ | 最も読み書きしやすい   |
| Git親和性          | ⭐⭐⭐⭐⭐ | 差分が最も見やすい     |

#### Option F: Microsoft Office (Word/Excel)

**概要**: ビジネス文書の事実上の標準。現在最も広く使われているドキュメント形式。

**長所**:

- ✅ ビジネスユーザーに馴染み深い
- ✅ リッチな表現力（書式、図表、埋め込み等）
- ✅ テンプレート機能
- ✅ エンタープライズでの普及率が圧倒的

**短所**:

- ❌ LLMによる解析・生成が極めて困難（バイナリ形式）
- ❌ プログラムでの処理が複雑（Open XML形式でも煩雑）
- ❌ 構造検証の標準がない
- ❌ セマンティック定義の仕組みがない
- ❌ Gitでのバージョン管理に不向き（差分が見えない）
- ❌ 自動化・CI/CD統合が困難
- ❌ ベンダーロックイン（Microsoft依存）
- ❌ ライセンスコスト

**評価**:

| 基準               | スコア   | コメント               |
| ------------------ | -------- | ---------------------- |
| AI可読性           | ⭐       | バイナリ形式で解析困難 |
| 構造検証           | ⭐       | 標準的なスキーマなし   |
| セマンティック対応 | ⭐       | 仕組みがない           |
| エコシステム       | ⭐⭐⭐   | ビジネス用途に限定     |
| 人間可読性         | ⭐⭐⭐⭐ | GUI編集は直感的        |
| Git親和性          | ⭐       | バイナリで差分不可     |

### 比較表

| 項目               | JSON       | YAML       | TOML     | XML        | Markdown   | MS Office | 備考                 |
| ------------------ | ---------- | ---------- | -------- | ---------- | ---------- | --------- | -------------------- |
| AI可読性           | ⭐⭐⭐⭐⭐ | ⭐⭐⭐     | ⭐⭐     | ⭐⭐       | ⭐⭐⭐⭐   | ⭐        | LLMトークン効率      |
| 構造検証           | ⭐⭐⭐⭐⭐ | ⭐⭐       | ⭐       | ⭐⭐⭐⭐⭐ | ⭐         | ⭐        | スキーマ標準の厳密さ |
| セマンティック対応 | ⭐⭐⭐⭐⭐ | ⭐         | ⭐       | ⭐⭐⭐⭐   | ⭐         | ⭐        | W3C標準対応          |
| エコシステム       | ⭐⭐⭐⭐⭐ | ⭐⭐⭐     | ⭐⭐     | ⭐⭐⭐⭐   | ⭐⭐⭐     | ⭐⭐⭐    | ツール・ライブラリ   |
| 人間可読性         | ⭐⭐⭐     | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐         | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐  | 直接編集のしやすさ   |
| Git親和性          | ⭐⭐⭐     | ⭐⭐⭐⭐   | ⭐⭐⭐⭐ | ⭐⭐       | ⭐⭐⭐⭐⭐ | ⭐        | 差分の見やすさ       |
| 総合スコア         | 28/30      | 18/30      | 11/30    | 19/30      | 16/30      | 9/30      | -                    |

### 最終判断

**選定**: JSON

**判断理由**:

1. **AI可読性が最重要** - Ukiyoueの核心は「AIと人間の協働」。LLMによる生成・解析の容易さは最優先事項であり、JSONのトークン効率とシンプルさは他を圧倒する
2. **構造検証とセマンティック対応の両立** - JSON Schema + JSON-LD という確立されたW3C標準により、厳密な構造検証とセマンティック定義の両方を実現できる
3. **エコシステムの圧倒的な充実** - あらゆるプログラミング言語、ツール、IDEがJSONを第一級市民として扱う。これは開発効率と将来の拡張性を保証する

**他の選択肢を採用しなかった理由**:

- **Markdown**: 「AIへのインプットといえばMarkdown」という印象があるが、実際には構造検証とセマンティック対応が不可能。人間可読性は高いが、Ukiyoueが必要とする厳密な検証には不向き
- **Microsoft Office**: 現在のビジネス文書の主流だが、バイナリ形式でLLMによる処理が困難。自動化・CI/CD統合も難しく、AI-First設計と根本的に相容れない
- **YAML/TOML**: 人間可読性は高いがセマンティック対応が弱く、Ukiyoueの3つの柱（対話可能性、自動生成可能性、再利用可能性）を実現できない
- **XML**: 構造検証は強力だがトークン効率が悪く、モダンな開発環境との親和性が低い

**トレードオフの受容**:

- ⚠️ 人間による直接編集が難しい: AIエージェントが主にドキュメントを生成するため、人間が直接JSONを編集する機会は限定的。必要な場合はIDEのJSON編集支援やフォーマッタを活用
- ⚠️ コメントが書けない: メタデータとして記述（`"$comment"` フィールド）や、別ファイルでドキュメント化することで対応
- ⚠️ Git差分の可読性: JSON専用のdiffツール（jd, json-diff）や、フォーマッタによる正規化で軽減

## 結果

### ポジティブな影響

- ✅ **AI-First設計の実現**: LLMによる高速・高精度なドキュメント生成が可能
- ✅ **厳密な品質保証**: JSON Schema (Draft 2020-12) による完全な構造検証
- ✅ **セマンティックウェブへの対応**: JSON-LD 1.1 により、W3C標準に準拠したセマンティック定義
- ✅ **開発効率の向上**: 豊富なライブラリ（Ajv, jsonld.js等）により、実装が迅速
- ✅ **将来の拡張性**: JSON Schemaの進化に追従でき、エコシステムの恩恵を継続的に受けられる

### ネガティブな影響

- ⚠️ 人間による直接編集の難しさ（軽減策: IDEサポート、AIエージェント活用）
- ⚠️ コメント記述の制約（軽減策: `$comment` フィールド、別ファイルドキュメント）

### 依存関係

**このADRに影響を与えるADR**:

- なし（最初の基盤決定）

**このADRが影響を与えるADR**:

- ADR-002: 構造検証手法の選定 - JSON Schemaが前提となる
- ADR-003: セマンティック定義手法の選定 - JSON-LDが前提となる
- ADR-004: スキーマ検証エンジンの選定 - JSON Schema対応ライブラリが必要
- ADR-005: コンポーネント識別方法の選定 - JSON構造への参照方法
- ADR-010: JSON Schemaライブラリの選定 - JSON Schema処理ライブラリ
- ADR-011: JSON-LDライブラリの選定 - JSON-LD処理ライブラリ

### 実装への影響

```yaml
新規作成が必要な箇所:
  - schemas/: JSON Schemaファイル群
  - semantics/context.jsonld: JSON-LD Context定義
  - examples/: サンプルJSONドキュメント

開発環境への影響:
  - IDE設定: JSON Schema関連付け、フォーマッタ設定
  - Git設定: JSON専用diffツールの検討
  - CI/CD: JSON整形・検証の自動化

移行計画:
  - ステップ1: スキーマファイルの作成（ADR-002）
  - ステップ2: JSON-LD Context定義（ADR-003）
  - ステップ3: サンプルドキュメントの作成
  - ステップ4: バリデーションツールの実装（ADR-004）
```

## 検証方法

### 成功基準

- [ ] AI（Claude, GPT-4等）がJSONドキュメントを正確に生成できる
- [ ] JSON Schemaによるバリデーションが100%機能する
- [ ] JSON-LDとしてRDFグラフに変換できる
- [ ] 開発者がIDEでJSON編集時に補完・検証支援を受けられる
- [ ] Gitでの差分管理が実用的なレベルで機能する

### リスクと軽減策

| リスク               | 影響度 | 発生確率 | 軽減策                                          |
| -------------------- | ------ | -------- | ----------------------------------------------- |
| 人間による編集が困難 | 中     | 高       | IDE支援、AIエージェント活用、YAML変換ツール提供 |
| Git差分が見づらい    | 低     | 中       | フォーマッタによる正規化、JSON専用diffツール    |
| コメントが書けない   | 低     | 高       | `$comment`フィールド、別ファイルドキュメント    |
| ファイルサイズの増加 | 低     | 中       | 圧縮、必要に応じてバイナリ形式も検討            |

### 将来の見直しトリガー

以下の条件が満たされた場合、このADRを見直す:

- [ ] LLMのYAML/TOML生成精度がJSONを大幅に上回る（2倍以上）
- [ ] JSON Schemaを超える強力な検証標準が登場し、広く普及する
- [ ] JSON-LDに代わるセマンティック定義標準が確立される
- [ ] コミュニティから「JSONが使いづらい」という強い要望が多数寄せられる（50%以上）

## 参考資料

- [JSON公式仕様 (RFC 8259)](https://www.rfc-editor.org/rfc/rfc8259.html) - IETF標準
- [JSON Schema公式サイト](https://json-schema.org/) - 最新仕様とドキュメント
- [JSON-LD 1.1 仕様](https://www.w3.org/TR/json-ld11/) - W3C勧告
- [YAML 1.2 仕様](https://yaml.org/spec/1.2.2/) - YAML公式仕様
- [TOML公式仕様](https://toml.io/) - Tom's Obvious, Minimal Language
- [Why JSON is better than XML](https://www.json.org/json-en.html) - JSON.org
- [JSON vs YAML: What's the Difference?](https://aws.amazon.com/compare/the-difference-between-yaml-and-json/) - AWS比較記事
